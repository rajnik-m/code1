<?xml version="1.0"?>
<doc>
<assembly>
<name>
CDBNACCESS
</name>
</assembly>
<members>
<member name="T:CARE.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:CARE.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:CARE.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="P:CARE.Access.Action.UseNegativeOffsets">
 <summary>When creating new Actions from a template, controls whether the deadline or delay days and months will be treated as positive or negative values.</summary>
 <returns>True if deadline or delay day and month values should be treated as negative values, otherwise False.</returns>
</member>
<member name="P:CARE.Access.Action.UseWorkingDays">
 <summary>When creating new Actions from a template, controls whether the date calculations will use elapsed days or working days.</summary>
 <returns>True if the date calculations will use working days, otherwise False.</returns>
 <remarks>When set to use working days, weekend and bank holiday days are excluded and the resultant date will always be a weekday.</remarks>
</member>
<member name="P:CARE.Access.Action.ActionTemplateNumber">
 <summary>When the Action has been created from a template, this will show the <see cref="P:CARE.Access.Action.ActionNumber">Action Number</see> of the template.</summary>
 <returns>Action number of the template used to create this Action, otherwise 0.</returns>
</member>
<member name="M:CARE.Access.Action.Delete(System.String,System.Boolean,System.Int32)">
 <summary>Delete this record.  If the Action is a Template then links to any Actions created from this template will be removed.</summary>
 <param name="pAmendedBy">User ID of the User performing the delete.</param>
 <param name="pAudit">Flag indicating whether the delete should be audited.</param>
 <param name="pJournalNumber">Journal number to be applied ot the audit record.</param>
</member>
<member name="M:CARE.Access.Action.DeleteWithSubActions(System.String@,System.Boolean@)">
 <summary>Delete this Action plus all linked Actions that have the same <see cref="P:CARE.Access.Action.MasterAction">Master Action</see> number as this Action and a <see cref="P:CARE.Access.Action.SequenceNumber">Sequence Number</see> that is greater than or equal to the sequence number of this Action.
 This will check that the user has the appropriate access rights to delete all of the Actions.</summary>
 <param name="pAmendedBy">User ID of the user performing the delete.</param>
 <param name="pAudit">Flag indicating whether the deletes should be audited.</param>
</member>
<member name="M:CARE.Access.Action.DeleteActions(System.String,System.String@,System.Boolean@)">
 <summary>Delete this Action plus the specified Actions.  Additionally this will cascade delete related data for the specified Actions.</summary>
 <param name="pActionNumbers">A comma-separated list of Action numbers to be deleted.</param>
 <param name="pAmendedBy">User ID of the user performing the delete.</param>
 <param name="pAudit">Flag indicating whether the delete of this Action should be audited.</param>
</member>
<member name="M:CARE.Access.Action.GetUserAccessRights">
 <summary>Gets the current user's <see cref="T:CARE.Access.AccessRights.DocumentAccessRights">Access Rights</see> to this Action.</summary>
 <remarks>There is no requirement for the Action to exist, as long as the <see cref="P:CARE.Access.Action.DocumentClass">DocumentClass</see> has been set.</remarks>
</member>
<member name="M:CARE.Access.Action.ToBeDeleted">
 <summary>Used when creating / updating Actions from provisional Actions to record that the Action is to be deleted.</summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Action.UserCanView">
 <summary>Can the current <see cref="T:CARE.Access.CDBUser">User</see> view this <see cref="T:CARE.Access.Action">Action</see>?</summary>
</member>
<member name="M:CARE.Access.Action.GetDataAsParameters(CARE.Access.CDBParameters)">
 <summary>Used by Web Services to extract all of the data into a <see cref="T:CARE.Access.CDBParameters">CDBParameters</see> collection.</summary>
</member>
<member name="M:CARE.Access.Action.SetDataFromXML(System.String,System.String)">
 <summary>Set the class up with values that have been returned via Web Services.</summary>
</member>
<member name="M:CARE.Access.Action.GetFieldDataType(System.String)">
 <summary>Gets the attribute <see cref="T:CARE.Data.CDBField.FieldTypes">data type</see>.</summary>
</member>
<member name="M:CARE.Access.Action.UpdateDatesFromProforma(CARE.Access.CDBEnvironment,CARE.Access.Action,System.DateTime)">
 <summary>Updates the <see cref="T:CARE.Access.Action">Action</see> dates from the specified Proforma (Template) <see cref="T:CARE.Access.Action">Action</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProForma">The Proforma (Template) <see cref="T:CARE.Access.Action">Action</see> used to update this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pProcessingDate">The base date to use for calculating the new Action dates.</param>
</member>
<member name="M:CARE.Access.Action.CreateFromProvisionalProforma(CARE.Access.Action,System.Int32,System.Int32)">
 <summary>Create a new <see cref="T:CARE.Access.Action">Action</see> from a provisional Action in the specified Proforma (Template) <see cref="T:CARE.Access.Action">Action</see>.</summary>
 <param name="pProforma">The Proforma (Template) <see cref="T:CARE.Access.Action">Action</see> used to create this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pMasterActionNumber">The master Action Number to be used.  The first <see cref="T:CARE.Access.Action">Action</see> in the <see cref="T:CARE.Access.ActionSet">ActionSet</see> is the master Action.</param>
</member>
<member name="M:CARE.Access.Action.SetChangeReason(System.String)">
 <summary>Set the Action Change Reason for an existing Action.</summary>
 <param name="pChangeReason">The change reason to be applied to the current changes.</param>
 <remarks>This will only set the change reason for an existing Action.</remarks>
</member>
<member name="M:CARE.Access.Action.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.Action,System.Int32,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,System.Int32,System.Int32)">
 <summary>Create a new <see cref="T:CARE.Access.Action">Action</see> from the specified Proforma (Template) <see cref="T:CARE.Access.Action">Action</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProForma">The Proforma (Template) <see cref="T:CARE.Access.Action">Action</see> used to create this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pMasterActionNumber">The master Action Number to be used.  The first <see cref="T:CARE.Access.Action">Action</see> in the <see cref="T:CARE.Access.ActionSet">ActionSet</see> is the master Action.</param>
 <param name="pActionNumber">The Action number to be assigned to this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pRelatedType">The type of object for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
 <param name="pActionerType">The type of object for an Actioner link to be created for each Action.</param>
 <param name="pActionerNumber">The number of the Actioner to be created for each Action.</param>
 <param name="pRelatedDocument">The number of a Document to be linked to each Action.</param>
 <param name="pRelatedExamCentreId">The number of an Exam Centre to be linked to each Action.</param>
</member>
<member name="M:CARE.Access.Action.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.Action,System.Int32,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,System.Int32,System.Int32,System.DateTime,System.Boolean)">
 <summary>Create a new <see cref="T:CARE.Access.Action">Action</see> from the specified Proforma (Template) <see cref="T:CARE.Access.Action">Action</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProForma">The Proforma (Template) <see cref="T:CARE.Access.Action">Action</see> used to create this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pMasterActionNumber">The master Action Number to be used.  The first <see cref="T:CARE.Access.Action">Action</see> in the <see cref="T:CARE.Access.ActionSet">ActionSet</see> is the master Action.</param>
 <param name="pActionNumber">The Action number to be assigned to this <see cref="T:CARE.Access.Action">Action</see>.</param>
 <param name="pRelatedType">The type of object for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
 <param name="pActionerType">The type of object for an Actioner link to be created for each Action.</param>
 <param name="pActionerNumber">The number of the Actioner to be created for each Action.</param>
 <param name="pRelatedDocument">The number of a Document to be linked to each Action.</param>
 <param name="pRelatedExamCentreId">The number of an Exam Centre to be linked to each Action.</param>
 <param name="pProcessingDate">The base date to use for calculating the new Action dates.</param>
 <param name="pCreateAction">True to save the new <see cref="T:CARE.Access.Action">Action</see> and related data in the database, otherwise False to set the Action data without saving.</param>
</member>
<member name="M:CARE.Access.ActionSubject.CloneForNewAction(CARE.Access.ActionSubject,System.Int32)">
 <summary>Clone the original <see cref="T:CARE.Access.ActionSubject">ActionSubject</see> record and set the Action Number to the supplied value.</summary>
 <param name="pRecord">The original <see cref="T:CARE.Access.ActionSubject">ActionSubject</see> record to clone.</param>
 <param name="pNewActionNumber">The Action Number to be set on the new record.</param>
</member>
<member name="T:CARE.Access.BulkMailer.BulkMailerFactory">
 <summary>
 This class is used to get an instance of a bulk mailer interface that is appropriate to the
 current environment.  It is the only supported way of obtaining a new <see cref="T:CARE.Access.BulkMailer.BulkMailer" />
 instance.  New bulk mailer interface implementations should be added here as required.
 </summary>
</member>
<member name="M:CARE.Access.BulkMailer.BulkMailerFactory.GetBulkMailerInstance(CARE.Access.CDBEnvironment)">
 <summary>
 Gets a new instance of an <see cref="T:CARE.Access.BulkMailer.BulkMailer" /> appropriate to the current environemt.
 </summary>
 <param name="pEnvironment">The current <see cref="T:CARE.Access.CDBEnvironment" />.</param>
 <returns>An appropriate <see cref="T:CARE.Access.BulkMailer.BulkMailer" /> instance.</returns>
</member>
<member name="T:CARE.Access.BulkMailer.BulkMailingStats">
 <summary>
 An immutable class to provide statistics about a bulk mailer mailing.
 </summary>
</member>
<member name="M:CARE.Access.BulkMailer.BulkMailingStats.#ctor(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.BulkMailer.BulkMailingStats" /> class.
 </summary>
 <param name="pSendDate">The date that the emails were sent.</param>
 <param name="pNumberSent">The number of emails sent.</param>
 <param name="pBounced">The number of emails that were bounced.</param>
 <param name="pOpened">The number of times the email was opened.</param>
 <param name="pClicked">The number of click throughs.</param>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailingStats.SendDate">
 <summary>
 The date that the emails were sent.
 </summary>
 <value>The email send date.</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailingStats.NumberSent">
 <summary>
 The number of emails that were sent.
 </summary>
 <value>The total emails sent.</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailingStats.Bounced">
 <summary>
 The number of emails that were bounced.
 </summary>
 <value>The bounce count.</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailingStats.Opened">
 <summary>
 The number of times the email was opened.
 </summary>
 <value>The opened count.</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailingStats.Clicked">
 <summary>
 The number of clicked throughs.
 </summary>
 <value>The click through count.</value>
</member>
<member name="T:CARE.Access.BulkMailer.BulkMailing">
 <summary>
 A bulk mailer mailing
 </summary>
<remarks>A bulk mailer mailing is a template that has been set up in the bulk mailer 
 to send to a mailing list.</remarks>
</member>
<member name="M:CARE.Access.BulkMailer.BulkMailing.#ctor(System.Int32,System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.BulkMailer.BulkMailing" /> class.
 </summary>
 <param name="pMailingId">The mailing identifier.</param>
 <param name="pMailing">The mailing name.</param>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailing.MailingId">
 <summary>
 The identifier of the mailing.
 </summary>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailing.Mailing">
 <summary>
 The name of the mailing.
 </summary>
</member>
<member name="T:CARE.Access.BulkMailer.DotMailer">
 <summary>
 A <see cref="T:CARE.Access.BulkMailer.BulkMailer" /> implementation specific to DotMailer.
 </summary>
</member>
<member name="M:CARE.Access.BulkMailer.DotMailer.#ctor(System.String,System.String,CARE.Access.CDBEnvironment)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.BulkMailer.DotMailer" /> class.
 </summary>
 <param name="pLoginId">The ID used to log in to DotMailer.</param>
 <param name="pPassword">The password used to log in to DotMailer.</param>
 <remarks>Instances of this class must be obtained using <see cref="M:CARE.Access.BulkMailer.BulkMailerFactory.GetBulkMailerInstance(CARE.Access.CDBEnvironment)" />
 and not and not by direct instanciation.  This constructor is declared as 'friend' to </remarks>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.AvailableMailings">
 <summary>
 The available DotMailer campaigns.
 </summary>
 <value>A list of the names and IDs of available DotMailer campaigns</value>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.MailingProperties(System.Int32)">
 <summary>
 The properties of a bulk mailer mailing.
 </summary>
 <param name="pMailingId">The id of the mailing to get the properties of.</param>
 <value>A <see cref="T:CARE.Access.BulkMailer.BulkMailingProperties" /> item for the mailing.</value>
</member>
<member name="M:CARE.Access.BulkMailer.DotMailer.MailToList(System.String,System.Int32,System.DateTime,System.String)">
 <summary>
 Send a campaign to a list of contacts.
 </summary>
 <param name="pContactsFilename">The name of a CSV file containing the contact data.</param>
 <param name="pMailingId">The ID of the DotMailer campaign to send.</param>
 <remarks>The CSV file must contain a column called Email.  Other data is stored by column name, with
 the a custom field for the column being useded on DotMailer if it exsits.  Column names are
 case insensitive.  Columns which do not have a corresponding custom data field are ignored.</remarks>
</member>
<member name="M:CARE.Access.BulkMailer.DotMailer.GetAddressBook(System.Int32)">
 <summary>
 Gets or creates an address book for the mailing.
 </summary>
 <param name="pMailingId">The ID of the mailing.</param><returns></returns>
</member>
<member name="M:CARE.Access.BulkMailer.DotMailer.CreateContactFromRow(System.String[],System.Data.DataTable,System.String)">
 <summary>
 Creates the contact from record in the CSV file.
 </summary>
 <param name="pValues">A string array containing the values.</param>
 <param name="pSchema">The schema.</param>
 <returns>The created <see cref="T:dotMailer.Sdk.Contacts.DmContact"/> object.</returns>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.Statistics(System.Int32)">
 <summary>
 The statistics for a DotMailer campaign.
 </summary>
 <param name="MailingId">The ID of the DotMailer campaign</param>
 <value>A list of campaign statistics</value>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.ActivityDetail(System.Int32,System.DateTime)">
 <summary>
 The activity detail for a mailing.
 </summary>
 <value>
 A list of <see cref="T:CARE.BulkMailerActvity" /> for the mailing
 </value>
 <param name="pMailingId">The ID of the mailing.</param>
   <param name="pSince">The Earliest dtae and time to get activities for.</param>
 <exception cref="T:System.NotSupportedException"></exception>
</member>
<member name="T:CARE.Access.BulkMailer.DotMailer.MailerInternals">
 <summary>
 An internal classs to manage the DotMailer interface.  It implements the required interfaces into the
 DotMailer SDK as lazy-initialised constant properties to avoid unnecessary overheads making repeated 
 web service calls to get these items.
 </summary>
</member>
<member name="M:CARE.Access.BulkMailer.DotMailer.MailerInternals.#ctor(System.String,System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.BulkMailer.DotMailer.MailerInternals" /> class.
 </summary>
 <param name="pLoginId">The ID to use when logging in to DotMailer.</param>
 <param name="pPassword">The password to use when logging in to DotMailer.</param>
 <remarks>As standard, if the DotMailer DLL is not found, IIS will intercept the error and just return a
 status 500.  We need a little more information to go back to the user than this, so we intercept the error 
 and throw a <see cref="T:CARE.CareException"/> with the original error as the <see cref="P:System.Exception.InnerException"/>.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.MailerInternals.AccountInfo">
 <summary>
 Gets account information for the DotMailer account.
 </summary>
 <remarks>As standard, if the DotMailer DLL is not found, IIS will intercept the error and just return a
 status 500.  We need a little more information to go back to the user than this, so we intercept the error 
 and throw a <see cref="T:CARE.CareException"/> with the original error as the <see cref="P:System.Exception.InnerException"/>.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.MailerInternals.AddressBookFactory">
 <summary>
 Gets the address book factory for the DotMailer account.
 </summary>
 <remarks>As standard, if the DotMailer DLL is not found, IIS will intercept the error and just return a
 status 500.  We need a little more information to go back to the user than this, so we intercept the error 
 and throw a <see cref="T:CARE.CareException"/> with the original error as the <see cref="P:System.Exception.InnerException"/>.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.MailerInternals.CampaignFactory">
 <summary>
 Gets the campaign factory for the DotMailer account.
 </summary>
 <remarks>As standard, if the DotMailer DLL is not found, IIS will intercept the error and just return a
 status 500.  We need a little more information to go back to the user than this, so we intercept the error 
 and throw a <see cref="T:CARE.CareException"/> with the original error as the <see cref="P:System.Exception.InnerException"/>.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.DotMailer.MailerInternals.ContactFactory">
 <summary>
 Gets the contact factory for the DotMailer account.
 </summary>
 <remarks>As standard, if the DotMailer DLL is not found, IIS will intercept the error and just return a
 status 500.  We need a little more information to go back to the user than this, so we intercept the error 
 and throw a <see cref="T:CARE.CareException"/> with the original error as the <see cref="P:System.Exception.InnerException"/>.</remarks>
</member>
<member name="T:CARE.Access.BulkMailer.BulkMailer">
 <summary>
 The generic interface implemented by all bulk mailers
 </summary>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailer.Mailings">
 <summary>
 The mailings available from this bulk mailer.
 </summary>
 <value>A list of available mailings as <see cref="T:CARE.Access.BulkMailer.BulkMailing" /> instances.</value>
 <remarks>A bulk mailer mailing is a template that has been set up in the bulk mailer 
 to send to a mailing list.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailer.MailingProperties(System.Int32)">
 <summary>
 The properties of a mailings from the bulk mailer.
 </summary>
 <param name="pMailingId">The id of the mailing to get the properties of.</param>
 <value>A <see cref="T:CARE.Access.BulkMailer.BulkMailingProperties" /> item for the mailing.</value>
</member>
<member name="M:CARE.Access.BulkMailer.BulkMailer.SendMailingToList(System.String,System.Int32,System.String,System.DateTime)">
 <summary>
 Initiate sending a mailing to a list of contacts.
 </summary>
 <param name="pContactsFilename">The name of a CSV file containing the contact data.</param>
 <param name="pMailingId">The ID of the mailing to send.</param>
</member>
<member name="M:CARE.Access.BulkMailer.BulkMailer.MailToList(System.String,System.Int32,System.DateTime,System.String)">
 <summary>
 Send a mailing to a list of contacts.
 </summary>
 <param name="pContactsFilename">The name of a CSV file containing the contact data.</param>
 <param name="pMailingId">The ID of the mailing to send.</param>
 <remarks>This is the function that actually performs the mailing.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailer.Statistics(System.Int32)">
 <summary>
 The statistics for a mailing.
 </summary>
 <param name="pMailingId">The ID of the mailing.</param>
 <value>The mailing statistics</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailer.ActivityDetail(System.Int32,System.DateTime)">
 <summary>
 The activity detail for a mailing.
 </summary>
 <param name="pMailingId">The ID of the mailing.</param>
 <param name="pSince">The Earliest dtae and time to get activities for.</param>
 <value>A list of <see cref="T:CARE.BulkMailerActvity" /> for the mailing</value>
</member>
<member name="P:CARE.Access.BulkMailer.BulkMailer.Environment">
 <summary>
 The environment.
 </summary>
 <value>The <see cref="T:CARE.Access.CDBEnvironment" /> instance related to this <see cref="T:CARE.Access.BulkMailer.BulkMailer"/>.</value>
</member>
<member name="T:CARE.Access.BulkMailer.NullBulkMailer">
 <summary>
 A dummy bulk mailer to satisfy the requirements of the system when no bulk
 mailer is configured.
 </summary>
</member>
<member name="P:CARE.Access.BulkMailer.NullBulkMailer.AvailableMailings">
 <summary>
 The mailings available from this bulk mailer.
 </summary>
 <value>
 A list of available mailings as <see cref="T:CARE.Access.BulkMailer.BulkMailing" /> instances.
 </value>
</member>
<member name="P:CARE.Access.BulkMailer.NullBulkMailer.MailingProperties(System.Int32)">
 <summary>
 A dummy mailing properties implmentation
 </summary>
 <param name="pId">The id of the mailing to get the properties of.</param>
 <value>A <see cref="T:CARE.Access.BulkMailer.BulkMailingProperties" /> item for the mailing.</value>
 <remarks>This method just throws a not supported exception.  Since <see cref="P:CARE.Access.BulkMailer.BulkMailer.Mailings" /> is
 always an empty list, this shouls never be called.</remarks>
</member>
<member name="M:CARE.Access.BulkMailer.NullBulkMailer.MailToList(System.String,System.Int32,System.DateTime,System.String)">
 <summary>
 A dummy mail to list implementation.
 </summary>
 <param name="pContactsFilename">The name of a CSV file containing the contact data.</param>
 <param name="pMailing">The ID of the mailing to send.</param>
 <remarks>This method just throws a not supported exception.  Since <see cref="P:CARE.Access.BulkMailer.BulkMailer.Mailings" /> is
 always an empty list, this shouls never be called.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.NullBulkMailer.Statistics(System.Int32)">
 <summary>
 The statistics for a mailing.
 </summary>
 <value>A list of mailing statistics.</value>
 <param name="MailingId">The ID of the mailing.</param>
 <remarks>This method just throws a not supported exception.  Since <see cref="P:CARE.Access.BulkMailer.BulkMailer.Mailings" /> is
 always an empty list, this shouls never be called.</remarks>
</member>
<member name="P:CARE.Access.BulkMailer.NullBulkMailer.ActivityDetail(System.Int32,System.DateTime)">
 <summary>
 The activity detail for a mailing.
 </summary>
 <value>
 A list of <see cref="T:CARE.BulkMailerActvity" /> for the mailing
 </value>
 <param name="pMailingId">The ID of the mailing.</param>
   <param name="pSince">The Earliest dtae and time to get activities for.</param>
 <exception cref="T:System.NotSupportedException"></exception>
</member>
<member name="T:CARE.Access.Category.CategoryUpdated">
 <summary>
 What has happened to a new Contact/Organisation Catergory
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Category.GetExistingCategories(CARE.Access.CDBParameters,CARE.Access.Category.ActivityEntryStyles)">
 <summary>
 
 </summary>
 <param name="pParams"></param>
 <param name="pStyle"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Category.GetExistingCategories(CARE.Access.CDBParameters,CARE.Data.CDBFields,CARE.Access.Category.ActivityEntryStyles)">
 <summary>
 
 </summary>
 <param name="pParams"></param>
 <param name="pWhereClause"></param>
 <param name="pStyle"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Category.IsValid(CARE.Access.CDBParameters,System.String,System.String,System.String,System.String,System.String)">
 <summary>
 Check if the record already exists in the database with activity, activityvalue, source, validfrom, validto   
 </summary>
 <param name="pParams"></param>
 <param name="pActivity"></param>
 <param name="pActivityValue"></param>
 <param name="pSource"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Category.Exists(CARE.Access.Category.ActivityEntryStyles,CARE.Access.CDBParameters,System.Int32@)">
 <summary>
 Check if the Categogy is existing then Update it else 
 </summary>
 <param name="pStyle"></param>
 <param name="pParams"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Address.CheckSetAddressLines">
 <summary>Checks and sets the address lines from the address, where the address is not blank but the address line(s) are not set</summary>
</member>
<member name="T:CARE.Access.Attachment">
 <summary>
 An miscelaneous array of bytes that can be attached to something
 </summary>
</member>
<member name="T:CARE.Access.Attachment.AttachmentFields">
 <summary>
 The fields in the databse table
 </summary>
</member>
<member name="M:CARE.Access.Attachment.AddFields">
 <summary>
 Adds the fields.
 </summary>
</member>
<member name="P:CARE.Access.Attachment.SupportsAmendedOnAndBy">
 <summary>
 Gets a value indicating whether the class supports amended on and by.
 </summary>
 <value>
 <c>true</c> if the class supports amended on and by; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:CARE.Access.Attachment.TableAlias">
 <summary>
 Gets the table alias.
 </summary>
 <value>
 The table alias fior this table.
 </value>
</member>
<member name="P:CARE.Access.Attachment.DatabaseTableName">
 <summary>
 Gets the name of the database table.
 </summary>
 <value>
 The name of the database table used to store instances of this class.
 </value>
</member>
<member name="M:CARE.Access.Attachment.#ctor(CARE.Access.CDBEnvironment)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.Attachment"/> class.
 </summary>
 <param name="pEnv">The envuironmemt to use when creating the instance.</param>
 <remarks>Use <see cref="M:CARE.Access.Attachment.GetInstance(CARE.Access.CDBEnvironment,System.Int32)"/> or <see cref="M:CARE.Access.Attachment.CreateInstance(CARE.Access.CDBEnvironment,System.String,System.Byte[])"/> as appropriate.</remarks>
</member>
<member name="P:CARE.Access.Attachment.AttachmentId">
 <summary>
 Gets the attachment identifier.
 </summary>
 <value>
 The unique identifier of this attachment.
 </value>
</member>
<member name="P:CARE.Access.Attachment.Name">
 <summary>
 Gets or sets the name.
 </summary>
 <value>
 The name of this attachment.
 </value>
</member>
<member name="P:CARE.Access.Attachment.Document">
 <summary>
 Gets or sets the binary content.
 </summary>
 <value>
 The binary content of the attachment.
 </value>
</member>
<member name="P:CARE.Access.Attachment.AmendedBy">
 <summary>
 Gets the amendeding user.
 </summary>
 <value>
 The the user that last updated the attachment.
 </value>
</member>
<member name="P:CARE.Access.Attachment.AmendedOn">
 <summary>
 Gets the amendment date.
 </summary>
 <value>
 The date that the last amendment to this attachment was made.
 </value>
</member>
<member name="M:CARE.Access.Attachment.GetInstance(CARE.Access.CDBEnvironment,System.Int32)">
 <summary>
 Gets an existing attachment from the database.
 </summary>
 <param name="pEnv">The environment to use.</param>
 <param name="pId">The identifier of the attachment to get.</param>
 <returns>The requested attachment or a null reference if the requested attachemnt doesn't exist</returns>
</member>
<member name="M:CARE.Access.Attachment.CreateInstance(CARE.Access.CDBEnvironment,System.String,System.Byte[])">
 <summary>
 Creates a new attachment.
 </summary>
 <param name="pEnv">The environment to use.</param>
 <param name="pName">Name of the attachment to create.</param>
 <param name="pContent">The binary data for this attachment.</param>
 <returns>The new attachnment</returns>
 <remarks>The created attachemnt will not exist on the database until it has been saved.</remarks>
</member>
<member name="M:CARE.Access.Attachment.Save(System.String,System.Boolean,System.Int32)">
 <summary>
 Saves the attachment.
 </summary>
 <param name="pAmendedBy">The amending user.</param>
 <param name="pAudit">if set to <c>true</c> the update will be auditted.</param>
 <param name="pJournalNumber">The journal number.</param>
</member>
<member name="M:CARE.Access.Attachment.Save(System.String,System.Boolean,System.Int32,System.Boolean)">
 <summary>
 Save the attachment
 </summary>
 <param name="pAmendedBy">The amending user</param>
 <param name="pAudit">if set to <c>true</c> the update will be auditted.</param>
 <param name="pJournalNumber">The journal number.</param>
 <param name="pForceAmendmentHistory">if set to <c>true</c> the creation of amendment history is forced</param>
</member>
<member name="M:CARE.Access.Attachment.SaveContent">
 <summary>
 Saves the binary content.
 </summary>
 <remarks>This must be called after the base class save to save the binary content as the base class cannot handle it</remarks>
 <exception cref="T:System.InvalidOperationException">Attempt to set the Document property of an email attachment updated no records</exception>
</member>
<member name="M:CARE.Access.Attachment.Update(CARE.Access.CDBParameters)">
 <summary>
 Block updates of attachments.
 </summary>
 <param name="pParameterList">The parameter list.</param>
 <remarks>Attachments are immutable and therefore updates are not allowed.</remarks>
 <exception cref="T:System.NotSupportedException">Attachemnts cannot be changed</exception>
</member>
<member name="M:CARE.Access.Communication.SetDeviceDefaultAndPreferred">
 <summary>
 Clear existing Preferred or Default prior to setting a new Preferred or Default.
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactAlert.GetContactAlerts(CARE.Access.CDBDataTable,System.Int32)">
 <summary>
 Returns a row for each alert where the AlertSQL returns a record
 </summary>
 <param name="pDataTable"></param>
 <param name="pContactNumber"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactAlert.GetContactAlerts(System.Int32)">
 <summary>
 Gets the alerts that are configured for the contact group to which the contact belongs
 </summary>
 <param name="pContactNumber"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:CARE.Access.ContactCategory.ContactCategoryUpdated">
 <summary>
 What has happened to a new Contact/Organisation Catergory
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactCategory.SaveActivity(CARE.Access.ContactCategory.ActivityEntryStyles,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
 <summary>
 Attempt to save an activity and provide feedback as to what happened
 </summary>
 <param name="pStyle"></param>
 <param name="pContactNumber"></param>
 <param name="pActivity"></param>
 <param name="pActivityValue"></param>
 <param name="pSource"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pQty"></param>
 <param name="pNotes"></param>
 <param name="pAmendedOn"></param>
 <param name="pAmendedBy"></param>
 <param name="pActivityDate"></param>
 <param name="pResponseChannel"></param>
 <returns>ContactCategoryUpdated enum member</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactCategory.AddActivity(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
 <summary>
 Add a contact or organisation category accoring to Activity configurations
 </summary>
 <param name="pContactNumber"></param>
 <param name="pActivity"></param>
 <param name="pActivityValue"></param>
 <param name="pSource"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pQuantity"></param>
 <param name="pNotes"></param>
 <param name="pActivityDate"></param>
 <param name="pResponseChannel"></param>
 <param name="pForceAmendmentHistory"></param>
 <returns>A message stating what has happened to the Activity passed as parameters</returns>
 <remarks>Used by import as an interface to Function AddActivity(ByVal pParams As CDBParameters)</remarks>
</member>
<member name="M:CARE.Access.ContactCategory.AddActivity(CARE.Access.CDBParameters)">
 <summary>
 Add a contact or organisation category accoring to Activity configurations. 
 </summary>
 <param name="pParams"></param>
 <returns>A message stating what has happened to the Activity passed as parameters</returns>
 <remarks>Taken from XMLAddData.AddActivity where it is called from. Import uses this as a function.</remarks>
</member>
<member name="M:CARE.Access.ContactLink.Init(System.Int32)">
 <summary>
 Initialises the current instance of the class from the primary key of the record.
 </summary>
 <param name="pLinkNumber"></param>
 <remarks>Note that Link Numbers are unique across 2 tables, the Contact Links and Organisation Links tables.
 This method will attempt retrieve its data from the current Link Type (i.e. Contact or Organisation Link).
 If no data is found then it will attempt to retrieve data from the other Link Type.  
 If no data is found in either table, it will reset its Link Type to its state prior to initialisation.
 </remarks>
</member>
<member name="M:CARE.Access.ContactLink.SaveInternal(System.String,System.Boolean,System.Int32,System.Boolean,System.Nullable{System.Boolean})">
 <summary>
 Call the base class Save method and checks if a complementary relationship needs to be created
 </summary>
 <param name="pAmendedBy"></param>
 <param name="pAudit"></param>
 <param name="pJournalNumber"></param>
</member>
<member name="M:CARE.Access.ContactPosition.SynchronizeAddress(CARE.Access.ContactAddress,System.String,System.Boolean)">
 <summary>Synchronize this ContactPosition with the ContactAddress.</summary>
 <remarks>It is assumed that this ContactPosition object has already been initialised for a valie Position.</remarks>
</member>
<member name="M:CARE.Access.EventSessionCpd.PreValidatePoints(CARE.Access.CDBParameters)">
 <summary>Validate CPD Points and CPD Points 2 to ensure that they are only numeric when configuration allows.</summary>
 <remarks>Uses the 'cpd_points_allow_numeric' configuration option.</remarks>
</member>
<member name="M:CARE.Access.EventSessionCpd.ValidateData">
 <summary>Validate the data before saving.</summary>
 <remarks>Records created by migrating existing data will not call this validation.</remarks>
</member>
<member name="M:CARE.Access.EventSessionCpd.ValidateEventAndSession(CARE.Access.CDBParameters)">
 <summary>When creating a new record, validate the Event and Session.</summary>
</member>
<member name="M:CARE.Access.DataSelection.CheckMergedContactOrOrganisation(System.Int32)">
 <summary>
 Return the current Contact number for a merged contact or organisation.
 BR17031
 </summary>
 <param name="pContactNumber">The merged contact (or organisation) number to search for</param>
 <returns>The current contact number for the merged contact, or pContactNumber if the contact number is not merged.</returns>
 <remarks>Relies on table dba_notes, and does not distinguish between contacts or organisations </remarks>
</member>
<member name="M:CARE.Access.DataSelection.FindMasterContact(System.Int32)">
 <summary>
 Finds the current contact number for a merged contact 
 BR17031
 </summary>
 <param name="pDuplicateNumber">The merged contact number to look for.</param>
 <returns>The current contact number for the merged contact or the merged contact number if the contact number is not merged</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DataSelection.GetChildLastExamDate(CARE.Access.CDBDataTable)">
 <summary>
 Get the Max (Last Exam Date) form the child exam units. This looks for all the child units for the current exam unit
 and extracts the latest Last Exam Date for child exam. 
 </summary>
 <param name="pDataTable">Data Table</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DataSelection.RestrictExamResults(CARE.Access.CDBDataTable,System.String)">
 <summary>Restrict display of exam Results.</summary>
 <remarks>For each row in the CDBDataTable, set the Current Mark / Grade / Result to the Previous Mark / Grade / Result when the ResultsReleaseDate is in the future</remarks>
</member>
<member name="M:CARE.Access.DataSelection.CheckAmountRGBValue(CARE.Access.CDBDataRow)">
 <summary>Check if the Amount and CurrencyAmount columns are the same value. If they are not then clear the RGB value for the Amount.</summary>
</member>
<member name="M:CARE.Access.Deduplication.DedupDataGeneratorFactory.GetSystemFactoryAttributes(CARE.Access.Deduplication.DedupDataSelection.DataSelectionTypes,CARE.Access.CDBEnvironment)">
 <summary>
 Returns the Factory Type that needs to be loaded based on how the system is configured.
 </summary>
 <param name="pFactoryType"></param>
 <returns></returns>
 <remarks>The Factory Type that is returned will be the one that is needed for the system's current implementation.
 For example, if the call is for a DedupDataSelectionType.Contacts but Uniserv is installed, then the factory type will be changed to DedupDataSelectionType.Contacts | DedupDataSelectionType.Uniserv
 </remarks>
</member>
<member name="M:CARE.Access.Deduplication.ContactUniservDedupDataGenerator.GenerateSQLCoreStatement(CARE.Access.CDBEnvironment,CARE.Access.Deduplication.DedupRule,CARE.Access.CDBParameters)">
 <summary>
 Generate the SQL required to implement a UniservContactDedupRule
 </summary>
 <param name="pEnv"></param>
 <param name="pRule">From ContactUniservdedupRules</param>
 <param name="pParams"></param>
 <returns>An SQL statement that implements the Rule Union with an SQL statement that will find contacts identified by Uniserv.</returns>
 <remarks>If Uniserv does not find any contacts there is no Union. Try not to change this code, manipulate the rules first.</remarks>
</member>
<member name="M:CARE.Access.Deduplication.ContactUniservDedupDataGenerator.GenerateCommonSQL(CARE.Access.CDBEnvironment,CARE.Access.Deduplication.DedupRule,CARE.Access.CDBParameters)">
 <summary>
 Generate SQL that will implement the pRule using the values passed in pParams
 </summary>
 <param name="pEnv"></param>
 <param name="pRule"></param>
 <param name="pParams"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Deduplication.ContactUniservDedupDataGenerator.GenerateUniservSQL(CARE.Access.CDBEnvironment,CARE.Access.Deduplication.DedupRule,CARE.Access.CDBParameters,System.String)">
 <summary>
 Generate similar SQL to GenerateCommonSQL, but just get the Uniserv contacts.
 </summary>
 <param name="pEnv"></param>
 <param name="pRule">Used to provide match data, not contact and addresses</param>
 <param name="pParams"></param>
 <param name="pUniservContactNumbers">CSV string of contact numbers returned by Uniserv</param>
 <returns>This function does not implement a rule, it selects contacts identified by Uniserv when it had the same information as the rule.</returns>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.Deduplication.DedupClause.Join.RawTableName">
 <summary>
 The SQL table that the join clause uses.  The Get of this property is purely for Xml serialization, or if you want the table name as it was originall passed.  Use the TableAlias and Table properties instead.
 </summary>
 <value></value>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DelegateActivity.Create(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
 <summary>DO NOT USE - USED BY VB6 MIGRATED CODE ONLY</summary>
 <param name="pDelegateNumber"></param>
 <param name="pActivity"></param>
 <param name="pActivityValue"></param>
 <param name="pQuantity"></param>
 <param name="pSource"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pActivityDate"></param>
 <param name="pNotes"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DelegateActivity.Update(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
 <summary>DO NOT USE - USED BY VB6 MIGRATED CODE ONLY</summary>
 <param name="pActivityValue"></param>
 <param name="pQuantity"></param>
 <param name="pSource"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pActivityDate"></param>
 <param name="pNotes"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DelegateLink.Create(System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
 <summary>DO NOT USE - USED BY VB6 MIGRATED CODE ONLY</summary>
 <param name="pEventDelegateNumber"></param>
 <param name="pContactNumber"></param>
 <param name="pRelationship"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pNotes"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DelegateLink.Update(System.Int32,System.String,System.String,System.String)">
 <summary>DO NOT USE - USED BY VB6 MIGRATED CODE ONLY</summary>
 <param name="pContactNumber"></param>
 <param name="pValidFrom"></param>
 <param name="pValidTo"></param>
 <param name="pNotes"></param>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.DeclarationLinesUnclaimed.FinancialHistoryDetailLines">
 <summary>
 Returns all the Financial History Detail lines from the Batch Transaction Analysis that are for a Product flagged as eligible for Gift Aid
 </summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.PostcodeValidation.QASProOnDemandPostcodeValidator.CreateAddressLine(CDBNServices.QASProOnDemand.Address)">
 <summary>
 This is the CSG Layout specification for QAAddress.AddressLine
 Address line 0-	address Line 1 as output by QADefault
 Address line 1-	address Line 2 as output by QADefault
 Address line 2-	Organisation Name-	O11
 Address line 3-	Whole PO Box-	B11
 Address line 4-	British Forces Post Office-	B12
 Address line 5-	Sub-Building Name-	P22
 Address line 6-	Sub-Building Number-	P21
 Address line 7-	Building Name-	P12
 Address line 8-	Whole Building Number-	P11
 Address line 9-	Whole Dependent thoroughfare-	S21
 Address line 10-Whole thoroughfare-	S11
 Address line 11-Double dependent locality-	L41
 Address line 12-Dependent Locality-	L31
 Address line 13-Town-	L21
 Address line 14-County-	L11
 Address Line 15-Postcode-	C11
 Address Line 16-Delivery Point Suffix-	A11
 Address Line 17-Code-Point Easting
 Address Line 18-Code-Point Northing
 Address Line 19-Local Education Authority Code
 Address Line 20-Local Education Authority Name
 </summary>
</member>
<member name="M:CARE.Access.PreTaxPayrollGivingPayment.Create(CARE.Access.PayrollGivingAgency,System.Collections.Hashtable,System.DateTime,System.Boolean,System.Int32,CARE.ArrayListEx)">
 <summary>Create a new record from a line in an input file.</summary>
 <param name="pAgency">The <see cref="T:System.Collections.Hashtable">Payroll Giving Agency</see> for this record.</param>
 <param name="pTitles"></param>
 <param name="pTransactionDate"></param>
 <param name="pPostBatchToCashBook"></param>
 <param name="pFields"></param>
</member>
<member name="M:CARE.Access.PreTaxPayrollGivingPayment.IsNetDonationSet">
 <summary>Has the NetDonation figure been set in the database?</summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.PreTaxPayrollGivingPayment.IsTotalDonationToCharitySet">
 <summary>Has the TotalDonationToCharity figure been set in the database?</summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.PreTaxPayrollGivingPayment.Reconcile(CARE.Access.CDBParameters,System.String)">
 <summary>Set this payment as having been reconciled.</summary>
 <param name="pParams"></param>
 <param name="pUnreconciledCode"></param>
</member>
<member name="M:CARE.Access.FutureMembershipType.InitFromType(CARE.Access.CDBEnvironment,System.String,System.Int32)">
 <summary>When updating a membership from one future type to another this is used to store the new future type details in order to update the Payment Plan.
 This method will be deprecated at some point and should NOT be used.</summary>
</member>
<member name="M:CARE.Access.FutureMembershipType.GetFutureRenewalAmount(CARE.Access.Member)">
 <summary>Calculate the future renewal amount for this future membership type.</summary>
 <param name="pMember">The <see cref="T:CARE.Access.Member">Member</see> to be used when the price is to be calculated using Rate Modifiers.</param>
 <returns>The calculated future renewal amount.</returns>
 <remarks>The routine will just calculate the price and return it.  The price is not stored at all.</remarks>
</member>
<member name="P:CARE.Access.ExamBookingUnit.ChildExamBookingUnits">
 <summary>Gets the ExamBookingUnit's that are children of this ExamBookingUnit.</summary>
</member>
<member name="T:CARE.Access.ExamCentreHistory">
 <summary>
 A record of changes to an exam centre's details.
 </summary>
</member>
<member name="T:CARE.Access.ExamCentreHistory.ColumnId">
 <summary>
 The datbase table fields are identified by this enumeration.
 </summary>
</member>
<member name="M:CARE.Access.ExamCentreHistory.#cctor">
 <summary>
 Initializes the <see cref="T:CARE.Access.ExamCentreHistory"/> class.
 </summary>
</member>
<member name="M:CARE.Access.ExamCentreHistory.CreateInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)">
 <summary>
 Creates a new history record.
 </summary>
 <param name="pEnv">The application environment.</param>
 <param name="pId">The exam centre unique identifier.</param>
 <param name="pDescription">The exam centre description being replaced.</param>
 <returns>A new <see cref="T:CARE.Access.ExamCentreHistory"/> instance for the data provided.</returns>
 <exception cref="T:System.ArgumentException">No exam centre exists with that ID.</exception>
</member>
<member name="M:CARE.Access.ExamCentreHistory.GetInstance(CARE.Access.CDBEnvironment,System.Int32,System.DateTime)">
 <summary>
 Gets an existing exam centre history record.
 </summary>
 <param name="pEnv">The application environment.</param>
 <param name="pExamCentreId">The application exam centre unique identifier.</param>
 <param name="pExamCentreDescriptionTimestamp">The timestamp of the change required.</param>
 <returns>>A <see cref="T:CARE.Access.ExamCentreHistory"/> instance for the record requested.</returns>
 <exception cref="T:System.ArgumentException">Requested row does not exist.</exception>
</member>
<member name="M:CARE.Access.ExamCentreHistory.GetById(CARE.Access.CDBEnvironment,System.Int32)">
 <summary>
 Get a history of the changes for an exam centre.
 </summary>
 <param name="pEnv">The application environemnt.</param>
 <param name="pId">The exam centre unique identifier.</param>
 <returns>A list of <see cref="T:CARE.Access.ExamCentreHistory"/> instances containing  a history of the changes to the exam centre requested.</returns>
</member>
<member name="P:CARE.Access.ExamCentreHistory.ColumnName(CARE.Access.ExamCentreHistory.ColumnId)">
 <summary>
 Gets the name of the column.
 </summary>
 <value>
 The name of the column.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.AliasedColumnName(CARE.Access.ExamCentreHistory.ColumnId)">
 <summary>
 Gets the aliased name of the column.
 </summary>
 <value>
 The name of the column with the standard alias added.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.ColumnNameList">
 <summary>
 Gets the list of column names.
 </summary>
 <returns>A read only list containing the column names.</returns>
</member>
<member name="M:CARE.Access.ExamCentreHistory.GetAliasedColumnNameList(CARE.Access.CDBEnvironment)">
 <summary>
 Gets the list of column names aliased by the standard alias.
 </summary>
 <param name="pEnv">The application env.</param>
 <returns></returns>
</member>
<member name="P:CARE.Access.ExamCentreHistory.Table">
 <summary>
 Gets the name of the database table.
 </summary>
 <value>
 The database table name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.ShortName">
 <summary>
 Gets the database table alias.
 </summary>
 <value>
 The database table alias.
 </value>
</member>
<member name="M:CARE.Access.ExamCentreHistory.#ctor(CARE.Access.CDBEnvironment)">
 <summary>
 Creates an empty instance of the <see cref="T:CARE.Access.ExamCentreHistory"/> class.  This is only used internally.  Applications 
 must use the <see cref="M:CARE.Access.ExamCentreHistory.CreateInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> or <see cref="M:CARE.Access.ExamCentreHistory.GetInstance(CARE.Access.CDBEnvironment,System.Int32,System.DateTime)" /> methods as appropriate.
 </summary>
 <param name="pEnv">The application environment.</param>
</member>
<member name="M:CARE.Access.ExamCentreHistory.#ctor(CARE.Access.CDBEnvironment,System.Data.DataRow)">
 <summary>
 Creates an instance of the <see cref="T:CARE.Access.ExamCentreHistory"/> class containing data from the supplied <see cref="T:System.Data.DataRow"/>.  
 This is only used internally.  Applications must use the <see cref="M:CARE.Access.ExamCentreHistory.CreateInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> or <see cref="M:CARE.Access.ExamCentreHistory.GetInstance(CARE.Access.CDBEnvironment,System.Int32,System.DateTime)" /> methods as appropriate.
 </summary>
 <param name="pEnv">The application environment.</param>
 <param name="pRow">The data row.</param>
</member>
<member name="M:CARE.Access.ExamCentreHistory.AddFields">
 <summary>
 Adds the fields.
 </summary>
</member>
<member name="P:CARE.Access.ExamCentreHistory.TableAlias">
 <summary>
 Gets the database table alias.
 </summary>
 <value>
 The database table alias.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.DatabaseTableName">
 <summary>
 Gets the name of the database table.
 </summary>
 <value>
 The database table name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.SupportsAmendedOnAndBy">
 <summary>
 Gets a value indicating whether [supports amended configuration and by].
 </summary>
 <value>
 <c>true</c> if [supports amended configuration and by]; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.ExamCentreId">
 <summary>
 Gets the exam centre unique identifier.
 </summary>
 <value>
 The unique identifier.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.Timestamp">
 <summary>
 Gets the timestamp of the change.
 </summary>
 <value>
 The timestamp.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.Description">
 <summary>
 Gets the description in use up to this point in time.
 </summary>
 <value>
 The description.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.CreatedBy">
 <summary>
 Gets the log name of the user that created the record.
 </summary>
 <value>
 The creating user's log name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.CreatedOn">
 <summary>
 Gets the date that this record was created on.
 </summary>
 <value>
 The creation date.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.AmendedBy">
 <summary>
 Gets the log name of the user that amended the record.
 </summary>
 <value>
 The amending user's log name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreHistory.AmendedOn">
 <summary>
 Gets the date that this record was last amended on.
 </summary>
 <value>
 The last amended date.
 </value>
</member>
<member name="M:CARE.Access.ExamUnit.IsUnitAccredited(CARE.Access.CDBEnvironment,CARE.Access.CDBDataTable,System.Boolean,System.Boolean)">
 <summary>
 Check If the units are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Environment class </param>
 <param name="pDT">Data table with the exam units</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamUnit.RemoveChildLinkUnits(CARE.Access.CDBEnvironment,System.Int32,CARE.Access.CDBDataTable)">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamUnit.CheckUnitAccreditationStatus(CARE.Access.CDBEnvironment,System.Int32,System.Boolean)">
 <summary>
 Check if the Units are accredited, then only add them to the lookup when called from trader or results entry screens
 </summary>
 <param name="pEnv">Environment class </param>
 <param name="pUnitLinkId">Unit Link Id to validate</param>
 <param name="pTrader">Trader flag</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamUnit.IsAccreditationValid(System.String,System.String,System.Boolean)">
 <summary>
 Validate the Date range specified for Accreditation
 </summary>
 <param name="pValidFrom">Accreditation Valid from</param>
 <param name="pValidTo">Accreditation valid To</param>
 <param name="pIgnoreValidity"> Ignore Validity</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentre.IsCentreAccredited(CARE.Access.CDBEnvironment,CARE.Access.CDBDataTable,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Envronment class</param>
 <param name="pDT">DatTable</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentre.CheckCentreAccreditationStatus(CARE.Access.CDBEnvironment,System.Int32,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Environment class</param>
 <param name="pCentreId">Centre Id </param>
 <param name="pTrader">Trader flag</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentre.IsAccreditationValid(System.String,System.String,System.Boolean)">
 <summary>
 Validate the Date range specified for Accreditation
 </summary>
 <param name="pValidFrom">Accreditation Valid from</param>
 <param name="pValidTo">Accreditation valid To</param>
 <param name="pIgnoreValidity"> Ignore Validity</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentre.ValidateValidFromTo(CARE.Access.CDBParameters)">
 <summary>
 
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentre.ValidateValidDatesFromParent(CARE.Access.CDBParameters)">
 <summary>
 A Child ExamCentre cannot have valid from and to dates outside it's parents valid from and to dates
 </summary>
 <param name="pParameterList"></param>
 <remarks>Only validates child exam Centres, i.e. this instance of ExamCentre has a parent</remarks>
</member>
<member name="M:CARE.Access.ExamCentre.ValidateValidDatesFromChildren(CARE.Access.CDBParameters)">
 <summary>
 A parent ExamCentre cannot have valid from and to dates outside it's childrens valid from and to dates
 </summary>
 <param name="pParameterList"></param>
 <remarks>Need to check all ExamCentres that have this instance as there parent, if any</remarks>
</member>
<member name="M:CARE.Access.ExamCentreUnit.IsCentreUnitAccredited(CARE.Access.CDBEnvironment,CARE.Access.CDBDataTable,System.Boolean,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Envronment class</param>
 <param name="pDT">DatTable</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentreUnit.IsCentreUnitAccredited(CARE.Access.CDBEnvironment,CARE.Access.CDBDataTable,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Envronment class</param>
 <param name="pDT">DatTable</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentreUnit.CheckCentreAccreditationStatus(CARE.Access.CDBEnvironment,System.Int32,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Environment class</param>
 <param name="pCentreUnitId">Centre Unit Id </param>
 <param name="pTrader">Trader flag</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamCentreUnit.IsAccreditationValid(System.String,System.String,System.Boolean)">
 <summary>
 Validate the Date range specified for Accreditation
 </summary>
 <param name="pValidFrom">Accreditation Valid from</param>
 <param name="pValidTo">Accreditation valid To</param>
 <param name="pIgnoreValidity"> Ignore Validity</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetExamCentreCategories(CARE.Access.CDBDataTable)">
 <summary>
  Get categories for Exam Centre
 </summary>
 <param name="pDataTable"> Data Table</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetExamCentreUnitLinkCategories(CARE.Access.CDBDataTable)">
 <summary>
 Get categories for Exam Centre Unit Link 
 </summary>
 <param name="pDataTable">Data table</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetAccreditationHistory(CARE.Access.CDBDataTable)">
 <summary>
 
 </summary>
 <param name="pDatatable"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetExamUnitLinkCategories(CARE.Access.CDBDataTable)">
 <summary>
 Get Categories for Exam Unit Link
 </summary>
 <param name="pDataTable">Data Table</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetLinkedExamUnits(System.String)">
 <summary>
 Gets all the list of all the Exam Units that are linked (directly - indirectly) with the main exam unit
 </summary>
 <param name="pExamUnit">Main Exam Unit</param>
 <returns>Comma seprated list of all the linked exam unit(s)</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.IsCentreAccredited(CARE.Access.CDBEnvironment,CARE.Access.CDBDataTable,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Envronment class</param>
 <param name="pDT">DatTable</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.CheckCentreAccreditationStatus(CARE.Access.CDBEnvironment,System.Int32,System.Boolean)">
 <summary>
 Check If the Centers are accredited then only add them when the lookup is called from Trader or Results entry
 </summary>
 <param name="pEnv">Environment class</param>
 <param name="pCentreId">Centre Id </param>
 <param name="pTrader">Trader flag</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamDataSelection.GetDocuments(CARE.Access.CDBDataTable)">
 <summary>
 Gets the communication_logs entry for Exam Units, Exam Centres or Exam Centre Units
 </summary>
 <param name="pDataTable">Data Table</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ExamStudentUnitHeader.DowngradeableMergeCompare(CARE.Access.ExamStudentUnitHeader)">
 <summary>
 Compares two exam student unit headers that are flagged as downgradeable
 </summary>
 <param name="pOtherESUH"></param>
 <returns>-1 if this Exam Student Unit Header is the </returns>
</member>
<member name="M:CARE.Access.ExamUnitLink.GetBaseUnitLinkId(CARE.Access.CDBEnvironment,System.Int32)">
 <summary>
 Returns the exam unit link Id that matches the current record's ExamUnitId1 and ExamUnitID2's Session 0 records
 </summary>
 <param name="pEnv">You must pass an existing Environment to this method as this object is not database-aware</param>
 <returns></returns>
 <remarks>The BasedUnitLinkId is the ExamUnitLink record whose ExamUnitId1 and ExamUnitId2 are the BaseExamUnitIds for the current ExamUnitLink's Parent (Unit1) and Child (Unit2) Units </remarks>
</member>
<member name="T:CARE.Access.ExamUnitStudyMode">
 <summary>
 A record of changes to an exam centre's details.
 </summary>
</member>
<member name="T:CARE.Access.ExamUnitStudyMode.ExamUnitStudyModeColumns">
 <summary>
 The datbase table fields are identified by this enumeration.
 </summary>
</member>
<member name="M:CARE.Access.ExamUnitStudyMode.#ctor(CARE.Access.CDBEnvironment)">
 <summary>
 Creates an empty instance of the <see cref="T:CARE.Access.ExamCentreHistory"/> class.  This is only used internally.  Applications 
 must use the <see cref="M:CARE.Access.ExamUnitStudyMode.CreateInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> or <see cref="M:CARE.Access.ExamUnitStudyMode.GetInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> methods as appropriate.
 </summary>
 <param name="pEnv">The application environment.</param>
</member>
<member name="M:CARE.Access.ExamUnitStudyMode.AddFields">
 <summary>
 Adds the fields.
 </summary>
</member>
<member name="P:CARE.Access.ExamUnitStudyMode.TableAlias">
 <summary>
 Gets the database table alias.
 </summary>
 <value>
 The database table alias.
 </value>
</member>
<member name="P:CARE.Access.ExamUnitStudyMode.DatabaseTableName">
 <summary>
 Gets the name of the database table.
 </summary>
 <value>
 The database table name.
 </value>
</member>
<member name="P:CARE.Access.ExamUnitStudyMode.SupportsAmendedOnAndBy">
 <summary>
 Gets a value indicating whether [supports amended configuration and by].
 </summary>
 <value>
 <c>true</c> if [supports amended configuration and by]; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:CARE.Access.ExamUnitStudyMode.AmendedBy">
 <summary>
 Gets the log name of the user that amended the record.
 </summary>
 <value>
 The amending user's log name.
 </value>
</member>
<member name="P:CARE.Access.ExamUnitStudyMode.AmendedOn">
 <summary>
 Gets the date that this record was last amended on.
 </summary>
 <value>
 The last amended date.
 </value>
</member>
<member name="T:CARE.Access.ExamCentreUnitStudyMode">
 <summary>
 A record of changes to an exam centre's details.
 </summary>
</member>
<member name="T:CARE.Access.ExamCentreUnitStudyMode.ExamCentreUnitStudyModeColumns">
 <summary>
 The datbase table fields are identified by this enumeration.
 </summary>
</member>
<member name="M:CARE.Access.ExamCentreUnitStudyMode.#ctor(CARE.Access.CDBEnvironment)">
 <summary>
 Creates an empty instance of the <see cref="T:CARE.Access.ExamCentreHistory"/> class.  This is only used internally.  Applications 
 must use the <see cref="M:CARE.Access.ExamCentreUnitStudyMode.CreateInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> or <see cref="M:CARE.Access.ExamCentreUnitStudyMode.GetInstance(CARE.Access.CDBEnvironment,System.Int32,System.String)" /> methods as appropriate.
 </summary>
 <param name="pEnv">The application environment.</param>
</member>
<member name="M:CARE.Access.ExamCentreUnitStudyMode.AddFields">
 <summary>
 Adds the fields.
 </summary>
</member>
<member name="P:CARE.Access.ExamCentreUnitStudyMode.TableAlias">
 <summary>
 Gets the database table alias.
 </summary>
 <value>
 The database table alias.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreUnitStudyMode.DatabaseTableName">
 <summary>
 Gets the name of the database table.
 </summary>
 <value>
 The database table name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreUnitStudyMode.SupportsAmendedOnAndBy">
 <summary>
 Gets a value indicating whether [supports amended configuration and by].
 </summary>
 <value>
 <c>true</c> if [supports amended configuration and by]; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreUnitStudyMode.AmendedBy">
 <summary>
 Gets the log name of the user that amended the record.
 </summary>
 <value>
 The amending user's log name.
 </value>
</member>
<member name="P:CARE.Access.ExamCentreUnitStudyMode.AmendedOn">
 <summary>
 Gets the date that this record was last amended on.
 </summary>
 <value>
 The last amended date.
 </value>
</member>
<member name="M:CARE.Access.BacsAmendment.InitFromBacsFile(CARE.Access.BacsAmendment.BACSSource,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
 <summary>
 This method will set all the calss fields with the values read from the CAMt053 file to store them in the BACS Amendments table for processing.
 </summary>
 <param name="pBacsSource">BACS source code  = "brbsCamt053"</param>
 <param name="pPayersIban">Payers IBAN Number</param>
 <param name="pPayersName">Payers Name</param>
 <param name="pAdvicesDate">Advice Date</param>
 <param name="pAmount">Amount od Direct debit that was rejected</param>
 <param name="pEndToEndId">Unique transaction identifier</param>
 <param name="pAdviceReason">Rejection reason</param>
 <param name="pPayersBic">Payers BIC Code</param>  
 <param name="pAdviceRefrence">DD mandate</param> 
 <param name="pPayeesIban">Iban of the payee</param>
 <param name="pPayeesBic">Business Identifier Code of the Payee, ISO 9362</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.BacsAmendment.ValidateBACSData(System.String@)">
 <summary>Validate the BACS data for BACS Messaging, returning the error code for any invalid data.</summary>
 <param name="pErrorCode">Error code identifying the invalid data</param>
 <returns>For any invalid date, the error code is returned</returns>
</member>
<member name="M:CARE.Access.BacsAmendment.TruncatePayerName(System.String)">
 <summary>
 Truncate the payers name to the length of payer name on bacs_amendments based on table maintenance_attributes BR18329
 </summary>
 <param name="pPayersName">payers name to be truncated</param>
 <returns>The payers name truncated</returns>
 <remarks>entry_length on maintenance_attributes is T-SQL smallint</remarks>
</member>
<member name="P:CARE.Access.BankAccount.AutoPayDelay">
 <summary>The Auto Pay Delay days for Direct Debits.</summary>
</member>
<member name="M:CARE.Access.BankAccount.GetAutoPayDelayDays(CARE.Access.PaymentPlan.ppAutoPayMethods)">
 <summary>Gets the Auto Pay Delay days appropriate for this Bank Account.</summary>
 <param name="pAutoPayMethod">The type of auto payment method.</param>
 <returns>If the <see cref="P:CARE.Access.BankAccount.AutoPayDelay"/> is not set then the fp_auto_pay_delay configuration option will be used.</returns>
</member>
<member name="M:CARE.Access.BankAccount.GetDDClaimFileFormat">
 <summary>Gets the Direct Debit claim file format for this Bank Account.</summary>
 <returns>If the <see cref="P:CARE.Access.BankAccount.DDClaimFileFormat"/> is not set then the fp_direct_debit_format configuration option will be used.</returns>
</member>
<member name="M:CARE.Access.FinancialHistoryDetail.IsEventBookingLine">
 <summary>Is this line an Event Booking line or a line created as a result of amending an Event Booking?</summary>
 <returns>True if this is line is linked to an Event Booking, otherwise False.</returns>
</member>
<member name="P:CARE.Access.FinancialHistoryDetail.IsFinancialAdjustment">
 <summary>Is this transaction line the result of a financial adjustment?</summary>
 <returns>True if the transaction line is the result of a financial adjustment, otherwise False</returns>
</member>
<member name="M:CARE.Access.FinancialHistoryDetail.GetRecordSetFields(CARE.Access.FinancialHistoryDetail.FinancialHistoryDetailRecordSetTypes)">
 <summary>DO NOT USE - VB6 CONVERTED CODE ONLY.</summary>
</member>
<member name="M:CARE.Access.FinancialHistoryDetail.Init(CARE.Access.CDBEnvironment,System.Int32@,System.Int32@,System.Int32@)">
 <summary>DO NOT USE - VB6 CONVERTED CODE ONLY.</summary>
</member>
<member name="M:CARE.Access.FinancialHistoryDetail.InitFromRecordSet(CARE.Access.CDBEnvironment,CARE.Data.CDBRecordSet,CARE.Access.FinancialHistoryDetail.FinancialHistoryDetailRecordSetTypes)">
 <summary>DO NOT USE - VB6 CONVERTED CODE ONLY.</summary>
</member>
<member name="M:CARE.Access.FinancialHistoryDetail.Save">
 <summary>DO NOT USE - VB6 CONVERTED CODE ONLY.</summary>
</member>
<member name="M:CARE.Access.Invoice.GetRecordTypeCode(CARE.Access.Invoice.InvoiceRecordType)">
 <summary>Returns the invoice RecordType code for the InvoiceRecordType enum</summary>
 <remarks>Valid values for the RecordType code are (I)nvoice, Credit (N)ote and Sales Ledger (C)ash</remarks>
</member>
<member name="M:CARE.Access.Invoice.GetRecordType(System.String)">
 <summary>Returns the invoice InvoiceRecordType enum for the RecordType code</summary>
 <remarks>Valid values for the RecordType code are (I)nvoice, Credit (N)ote and Sales Ledger (C)ash</remarks>
</member>
<member name="M:CARE.Access.Invoice.GetAdjustmentStatusCode(CARE.Access.Invoice.InvoiceAdjustmentStatus)">
 <summary>Gets the invoice AdjustmentStatus code for the InvoiceAdjustmentStatus enum.</summary>
 <remarks>Valid values for the AdjustmentStatus as (A)djusted, (M)oved, (R)eversed and null (normal).</remarks>
</member>
<member name="M:CARE.Access.Invoice.GetAdjustmentStatus(System.String)">
 <summary>Gets the InvoiceAdjustmentStatus enum for the InvoiceAdjustmentStatus code.</summary>
 <remarks>Valid values for the AdjustmentStatus as (A)djusted, (M)oved, (R)eversed and null (normal).</remarks>
</member>
<member name="M:CARE.Access.Invoice.IsPartiallyRefunded(CARE.Data.CDBConnection,System.Int32)">
 <summary>
 Returns whether the invoice has been refunded or partially refunded
 </summary>
 <param name="pConnection"></param>
 <param name="pInvoiceNumber"></param>
 <remarks>Applicable for example where the invoice was for multiple event/exam bookings and one of the bookings has been cancelled resulting in a reversal and credit note</remarks>
</member>
<member name="M:CARE.Access.Invoice.SetInvoiceAmount">
 <summary>Calculate the Invoice Amount using Invoice Details and Batch Transaction Analysis</summary>
 <remarks>This is only run if the Invoice Amount has not previously been set</remarks>
</member>
<member name="M:CARE.Access.Invoice.RemoveAllocations">
 <summary>Remove the allocations from either (1) an invoice / credit Note, or (2) an invoice payment</summary>
 <returns>Batch / Transaction reference of the adjustment transaction</returns>
</member>
<member name="P:CARE.Access.Invoice.RecordType">
 <summary>Returns the record type code of the Invoice.</summary>
 <remarks>If the RecordType enum value is required then please see the InvoiceType property.</remarks>
</member>
<member name="P:CARE.Access.Invoice.InvoiceType">
 <summary>Returns an InvoiceRecordType enum value representing the type of Invoice.</summary>
 <remarks>If the actual RecordType code is required then please see the RecordType property.</remarks>
</member>
<member name="M:CARE.Access.Invoice.PaymentHistoryCount">
 <summary>Used by CDBNet to decide whether to display the Remove Allocations menu</summary>
 <returns>Count of Invoice Payment History records</returns>
</member>
<member name="M:CARE.Access.Invoice.ProcessInvoicePaymentHistory(System.Boolean)">
 <summary>When removing allocations for an invoice / invoice payment, perform a financial adjustment of the payment history</summary>
 <param name="pIsInvoice">Boolean flag indicating whether this is an Invoice</param>
 <returns>Batch / Transaction reference for the adjustment(s)</returns>
 <remarks>Only used by RemoveAllocations</remarks>
</member>
<member name="M:CARE.Access.Invoice.AllocationsAmount(System.Boolean,System.Boolean,System.Boolean@)">
 <summary>Calculates the sum of payment allocations agaimst this invoice</summary>
 <param name="pExcludeCreditNotes">Exclude credit note allocations</param>
 <param name="pIncludeUnpostedTransactions">Include unposted transaction allocations</param>
 <param name="pContainsUnpostedTransactions">When pIncludeUnpostedTransactions is True, indicates whether the allocations amount includes unposted allocations</param>
 <returns>Sum of allocations for this invoice</returns>
</member>
<member name="M:CARE.Access.Invoice.GetAdjustmentInvoiceAmounts(System.Int32,System.Int32,System.Boolean)">
 <summary>Get the InvoiceAmount of a cash-invoice for a re-analysed sales ledger transaction. Only used by Batch Posting when creating the Sales Ledger Invoice.</summary>
 <param name="pBatchNumber">Batch Number of the adjustment transaction.</param>
 <param name="pTransactionNumber">Transaction Number of the adjustment transaction.</param>
 <param name="pFromBatchPosting">Is the cash-invoice currently being created by Batch Posting?</param>
 <returns>The calculated InvoiceAmount</returns>
 <remarks>Only used by Batch Posting when creating the Sales Ledger Invoice.</remarks>
</member>
<member name="M:CARE.Access.Invoice.GetAdjustmentInvoiceAmounts(System.Int32,System.Int32,System.Boolean,System.String,System.Double@)">
 <summary>Get the InvoiceAmount of a cash-invoice for a re-analysed sales ledger transaction. Only used by Batch Posting when creating the Sales Ledger Invoice.</summary>
 <param name="pBatchNumber">Batch Number of the adjustment transaction.</param>
 <param name="pTransactionNumber">Transaction Number of the adjustment transaction.</param>
 <param name="pFromBatchPosting">Is the cash-invoice currently being created by Batch Posting?</param>
 <param name="pSalesLedgerAccount">Sales Ledger Account of the adjustment transaction. Only used when <paramref name="pFromBatchPosting">pFromBatchPosting</paramref> is False.</param>
 <param name="pAmountPaid">Set to the sum of the AmountPaid</param>
 <returns>The calculated InvoiceAmount</returns>
 <remarks>Only used by Batch Posting when creating the Sales Ledger Invoice.</remarks>
</member>
<member name="P:CARE.Access.Invoice.FinancialHistory">
 <summary>Gets the <see cref="P:CARE.Access.Invoice.FinancialHistory">FinancialHistory</see> for this Invoice.</summary>
</member>
<member name="P:CARE.Access.Invoice.IsFinancialAdjustmentInvoice">
 <summary>Gets a boolean indicating whether this Invoice is a result of a Financial Adjustment.</summary>
 <returns></returns>
</member>
<member name="P:CARE.Access.Loan.InterestCapitalisationDate">
 <summary>Gets the date Capitalisation last took place</summary>
 <remarks>This is the date this Loan was last capitalised</remarks>
</member>
<member name="M:CARE.Access.Loan.InitFromPaymentPlan(System.Int32)">
 <summary>Initialise the Loan from the Payment Plan Number.</summary>
 <param name="pPaymentPlanNumber">The number of the Payment Plan the Loan is linked to</param>
 <remarks>The loan must not have been cancelled</remarks>
</member>
<member name="M:CARE.Access.Loan.InitFromPaymentPlan(System.Int32,System.Boolean)">
 <summary>Initialise the Loan from the Payment Plan Number.</summary>
 <param name="pPaymentPlanNumber">The number of the Payment Plan the Loan is linked to</param>
 <param name="pCancelledLoan">Set to True if the Loan is cancelled, otherwise set to False</param>
</member>
<member name="M:CARE.Access.Loan.UpdateInterestRate(System.Double,System.String)">
 <summary>Update the Interest Rate and add a record to the Loan Interest Rates table</summary>
 <param name="pNewInterestRate">The new Interest Rate</param>
 <param name="pChangeDate">The date the new interest rate takes effect</param>
</member>
<member name="M:CARE.Access.Loan.GetInterestRatesForPeriod(System.DateTime,System.DateTime)">
 <summary>Gets a CollectionList of all LoanInterestRate's for the period in question</summary>
 <returns>CollectionList of chosen LoanInterestRate objects</returns>
</member>
<member name="M:CARE.Access.Loan.SelectLoanInterestRates">
 <summary>Build CollectionList of LoanInterestRate objects. If there are no Loan Interest Rates then collection just contains the default interest</summary>
</member>
<member name="P:CARE.Access.Loan.LoanCapitalisationDate">
 <summary>Gets the date the Loan Capitalisation takes place</summary>
 <remarks>This is the date that Capitalisation takes place and not the date this individual Loan was capitalised</remarks>
</member>
<member name="M:CARE.Access.Loan.RequiresCapitalisation">
 <summary>Does the Loan require Capitalisation?</summary>
</member>
<member name="M:CARE.Access.LoanInterestRate.AddOrUpdate(System.Int32,System.Double,System.String)">
 <summary>Adds a new LoanInterestRate or updates an existing record with the new InterestRate</summary>
</member>
<member name="M:CARE.Access.PurchaseInvoice.CloneWithDetails(CARE.Access.CARERecord,CARE.Access.CDBParameters)">
 <summary>Clone the PurchaseInvoice and all of it's PurchaseInvoiceDetail lines.</summary>
 <param name="pRecord">The existing PurchaseInvoice to be cloned.</param>
 <param name="pParams">CDBParamaters collection for any data that may need to be set differently each time.</param>
</member>
<member name="M:CARE.Access.PurchaseInvoice.CancelWithDetails(System.String,System.String,System.String,System.String,System.String)">
 <summary>Cancel the Purchase Invoice and all of it's Details.</summary>
 <param name="pCancelReason">Reason for the cancellation.</param>
 <param name="pCancelBy">User performing the cancellation.</param>
 <param name="pCancelOn">Date cancellation takes place.</param>
 <param name="pCancelSource">The source of the cancellation.</param>
 <param name="pAdjustmentStatus">The adjustment status that should be applied.</param>
</member>
<member name="M:CARE.Access.FundraisingPaymentHistory.DeleteLinks(System.Int32,System.Int32)">
 <summary>Confirming a provisional transaction may have been configured so that the link to a Fundraising Request payment is no longer required. So this will remove those unwanted links.</summary>
 <param name="pBatchNumber">Provisional Batch Number</param>
 <param name="pTransactionNumber">Provisional Transaction Number</param>
 <remarks>This will delete all the records for the Batch Number and Transaction Number.</remarks>
</member>
<member name="M:CARE.Access.Organisation.DeleteMergedOrganisation(System.String,System.Boolean,System.Int32)">
 <summary>Delete the Organisation following an Organisation Merge.</summary>
 <remarks>This method does NOT check data, delete the dummy Contact or delete other related data.
  It must only be called after a merge when we know all related data has been moved.</remarks>
</member>
<member name="M:CARE.Access.ContactCpdPoint.CreateFromEventSessionCPD(CARE.Access.EventSessionCpd,System.DateTime,System.Int32,System.Int32)">
 <summary>Create a new <see cref="T:CARE.Access.ContactCpdPoint">ContactCpdPoint</see> record from an existing <see cref="T:CARE.Access.EventSessionCpd">EventSessionCpd</see>.</summary>
 <param name="pEventSessionCPD">The <see cref="T:CARE.Access.EventSessionCpd">EventSessionCpd</see> to create Points from.</param>
 <param name="pSessionStartDate">Session start date. This will become the <see cref="P:CARE.Access.ContactCpdPoint.PointsDate">points date</see>.</param>
 <param name="pContactNumber"><see cref="P:CARE.Access.ContactCpdPoint.ContactNumber">Contact number</see> the Points apply to.</param>
 <param name="pCPDPeriodNumber">When the Points are to be linked to a <see cref="T:CARE.Access.ContactCpdPeriod">ContactCpdPeriod</see> the <see cref="P:CARE.Access.ContactCpdPoint.ContactCpdPeriodNumber">period number</see> to link to.</param>
</member>
<member name="M:CARE.Access.CpdCategory.IsValidForPointsEntry(System.DateTime)">
 <summary>Validates that the Category is approved and valid based upon it's valid from and to dates.</summary>
 <returns>True if it is valid, otherwise False.</returns>
</member>
<member name="M:CARE.Access.CpdCycleType.IsFixedCPDCycleType">
 <summary>Is this a fixed CPD Cycle Type or a flexible CPD Cycle Type?</summary>
 <returns>True if this is a fixed CPD Cycle Type, otherwise False.</returns>
</member>
<member name="M:CARE.Access.Cheque.Cancel(System.String,System.String,System.String,System.String,System.String)">
 <summary>Cancel the Cheque.</summary>
 <param name="pCancelReason">Reason for the cancellation.</param>
 <param name="pCancelBy">User performing the cancellation.</param>
 <param name="pCancelOn">Date cancellation takes place.</param>
 <param name="pCancelSource">The source of the cancellation.</param>
 <param name="pAdjustmentStatus">The adjustment status that should be applied.</param>
</member>
<member name="P:CARE.Access.ProductRate.RenewalPrice(System.Boolean,System.Int32)">
 <summary>Gets the Renewal Price for this Rate</summary>
 <param name="pFuture">Set to True to always return the Future Price, otherwise Set to False to return the Current Price</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.RenewalPrice(System.Boolean,System.Int32,System.String)">
 <summary>Gets the Renewal Price for this Rate</summary>
 <param name="pFuture">Set to True to always return the Future Price, otherwise Set to False to return the Current Price</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pRenewalDate">The Payment Plan Renewal Date</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.RenewalPrice(System.Boolean,System.Int32,System.Double,CARE.Access.VatRate,System.DateTime)">
 <summary>Gets the Renewal Price for this Rate</summary>
 <param name="pFuture">Set to True to always return the Future Price otherwise Set to False to return the Current Price</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pQuantity">The number of units required. Returned Price will have been multiplied by this figure</param>
 <param name="pVATRate">For VAT-exclusive Rates this will be used for calculating the VAT element of the returned Price</param>
 <param name="pRenewalDate">The Payment Plan Renewal Date</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after multipling by pQuantity and then adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.Int32)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.DateTime,CARE.Access.Contact)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pModifierContact">Any modifier Contact applicable to this Rate that may affect the Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.DateTime,System.Int32)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.Int32,CARE.Access.VatRate)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pVATRate">For VAT-exclusive Rates this will be used for calculating the VAT element of the returned Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.DateTime,System.Int32,System.Double,CARE.Access.VatRate)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pQuantity">The number of units required. Returned Price will have been multiplied by this figure</param>
 <param name="pVATRate">For VAT-exclusive Rates this will be used for calculating the VAT element of the returned Price</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after multipling by pQuantity and then adding VAT (if required to be added)</remarks>
</member>
<member name="P:CARE.Access.ProductRate.Price(System.DateTime,System.Int32,System.Double,CARE.Access.VatRate,System.Double,System.Int32,System.Int32)">
 <summary>Gets the Price for this Rate</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pQuantity">The number of units required. Returned Price will have been multiplied by this figure</param>
 <param name="pVATRate">For VAT-exclusive Rates this will be used for calculating the VAT element of the returned Price</param>
 <param name="pSourceDiscountPercentage">Discount percentage to be applied</param>
 <param name="pTermMonths">For Pro-rated Payment Plans, the number of months in the current Plan term</param>
 <param name="pProRataMonths">For Pro-rated Payment Plans, the number of months worth of Price that is required to be returned</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>The calculated Price is returned after multipling by pQuantity, deducting any pSourceDiscountPercentage, reducing to be for just pProrataMonths and then adding VAT (if required to be added)</remarks>
</member>
<member name="M:CARE.Access.ProductRate.SetNoVatExclusiveVatRequired">
 <summary>
 Sets the NoVatExclusiveVatRequired flag- required to prevent VAT being added for VAT exclusive rates
 </summary>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.ProductRate.PriceWithoutVAT(System.DateTime,System.Double)">
 <summary>Gets the Price for this VAT-Exclusive Rate without adding VAT</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pQuantity">The number of units required. Returned Price will have been multiplied by this figure</param>
 <returns>Calculated price without VAT</returns>
</member>
<member name="P:CARE.Access.ProductRate.PriceWithoutVAT(System.DateTime,System.Double,System.Int32,System.Double,System.Int32,System.Int32)">
 <summary>Gets the Price for this VAT-Exclusive Rate without adding VAT</summary>
 <param name="pTransactionDate">Date the Price is required for</param>
 <param name="pQuantity">The number of units required. Returned Price will have been multiplied by this figure</param>
 <param name="pModifierContactNumber">Contact Number for any modifiers applicable to this Rate that may affect the Price</param>
 <param name="pSourceDiscountPercentage">Discount percentage to be applied</param>
 <param name="pTermMonths">For Pro-rated Payment Plans, the number of months in the current Plan term</param>
 <param name="pProRataMonths">For Pro-rated Payment Plans, the number of months worth of Price that is required to be returned</param>
 <returns>Calculated price without VAT</returns>
</member>
<member name="P:CARE.Access.VatRate.CurrentPercentage(System.String)">
 <summary>Gets the VAT Percentage was current on the Transaction Date</summary>
 <param name="pTransactionDate">Date the VAT Percentage is required for</param>
 <returns>VAT Percentage</returns>
</member>
<member name="M:CARE.Access.VatRate.CalculateVATAmount(System.Double,System.Boolean,System.String)">
 <summary>Calculates the VAT Amount for the entered Amount</summary>
 <param name="pAmount">The amount that requires the VAT calculation</param>
 <param name="pVATExclusive">Boolean flag indicating whether the amount excludes VAT</param>
 <param name="pTransactionDate">Date the VAT is to be calculated for</param>
 <returns>VAT Amount</returns>
</member>
<member name="M:CARE.Access.VatRate.CalculateVATAmount(System.Double,System.Boolean,System.Double)">
 <summary>Calculates the VAT Amount for the entered Amount</summary>
 <param name="pAmount">The amount that requires the VAT calculation</param>
 <param name="pVATExclusive">Boolean flag indicating whether the amount excludes VAT</param>
 <param name="pPercentage">The VAT Percentage to be used for the VAT calculation</param>
 <returns>VAT Amount</returns>
</member>
<member name="M:CARE.Access.VatRate.InitFromRecordSetWithHistory(CARE.Data.CDBRecordSet)">
 <summary>Initialise the class and build collection of any VAT History</summary>
 <param name="pRecordSet"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.VatRate.GetHistoricVATPercentage(System.String)">
 <summary>Get the VAT Percentage that was current at the transaction date</summary>
 <param name="pTransactionDate">The date the VAT percentage is required for</param>
 <returns>VAT Rate percentage</returns>
</member>
<member name="M:CARE.Access.VatRate.SelectHistoricVATData">
 <summary>Build CollectionList of VATRateHistory objects</summary>
</member>
<member name="T:CARE.Access.AccountNoVerify.AccValStruct">
 <summary>
 Always use the custom constructor when declaring New. This will set the correct length of fields that is required in third party DLL
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.AccountNoVerify.ValidateBankDetails(System.String,System.String,System.String@)">
 <summary>Validate Bank Details using classes that inherit the IBankAccountValidation interface.</summary>
 <param name="pSortCode">The Sort Code to be validated.  This must be present.</param>
 <param name="pAccountNumber">The Account Number to be validated.  This can be an empty string if only the Sort Code is to be validated.</param>
 <returns>Returns an <see cref="T:CARE.Access.AccountNoVerify.AccountNoVerifyResult">Account Number Verified</see>enum.</returns>
</member>
<member name="M:CARE.Access.InvoicePaymentHistory.InitFromBatchTransactionLine(System.Int32,System.Int32,System.Int32)">
 <summary>Initialise InvoicePaymentHistory using Batch, Transaction and Line numbers</summary>
 <remarks>If record cannot be found with these numbers then it will be initialised using the Allocation Batch, Transaction and Line numbers</remarks>
</member>
<member name="M:CARE.Access.InvoicePaymentHistory.Reverse(System.String,System.Int32,System.Int32,System.Int32,System.DateTime)">
 <summary>Marks this record as having been adjusted and creates a new record for the reversal</summary>
 <param name="pStatus">Adjustment status</param>
 <param name="pBatchNumber">Adjustment batch number</param>
 <param name="pTransactionNumber">Adjustment transaction number</param>
 <param name="pLineNumber">Adjustment line number</param>
 <param name="pTransactionDate">Adjustment date</param>
</member>
<member name="M:CARE.Access.InvoicePaymentHistory.GetAllocationNumbers(System.Int32@,System.Int32@,System.Int32@)">
 <summary>Gets the Batch / Transaction / Line numbers for the allocation transaction</summary>
 <param name="pAllocationBatchNumber">Returns the allocation batch number</param>
 <param name="pAllocationTransactionNumber">Returns the allocation transaction number</param>
 <param name="pAllocationLineNumber">Returns the allocation line number</param>
</member>
<member name="T:CARE.Access.ICardAuthorisationService">
 <summary>
 All the authorisatiion services should implement this interface for consistency 
 </summary>
 <remarks>Only TnsHostedPayment class is implementing this at the moment''' </remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.#ctor(CARE.CardSettings)">
 <summary>
 Constructor with CardSettings
 </summary>
 <param name="pCardSettings"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.SendRequest(System.String)">
 <summary>
 Sends the request to Get the Session ID from the TNS to start the Authentication Process. This method then also used to
 send the transaction details to the TNS for actual payment once the card details are authorised
 </summary>
 <returns>True if connection is successful else false</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetResponseData">
 <summary>
 Parse the Tns resposne data and store in the key value pair (ParameterList)
 </summary>
 <returns>Tns response data as parameterList</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetRawResponseData">
 <summary>
 Returns the unformatted response data
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetResponseData(System.String)">
 <summary>
 Get the response data for the specified field
 </summary>
 <param name="pFieldName">response field name</param>
 <returns>response field value</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetRequestData(System.String,System.Int32,System.String)">
 <summary>
 Creates the TNS request data. Transaction request will be sent to TNS for Pay operation to charge the amount from the card
 </summary>
 <param name="pSession">TNS session ID used when card details were send for authentication to TNS</param>
 <param name="pTransactionID">Unique Transaction ID number should be more than TRANS_START_RANGE</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetRequestData">
 <summary>
 This function adds the fields required to send the request to TNS 
 </summary>
 <returns>Key value pair of Requested data</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.GetErrorCode(System.String)">
 <summary>
 Tns response codes 
 </summary>
 <param name="pResult">Result string </param>
 <returns>Response code</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.ParseRequestData(CARE.Collections.ParameterList)">
 <summary>
 This function formats the request data into format required by TNS
 </summary>
 <returns>Request data in the format require by the TNS</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TnsHostedPayment.CheckResponse">
 <summary>
 Check the response string for success status
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:CARE.Access.LogFileWriter">
 <summary>
 A <see cref="T:System.IO.StreamWriter" /> for writing to a log file.
 </summary>
 <remarks>The log file is created with a base log file name and a maximum size.  When data is written to the stream,
 the size of the file is checked to ensure that the write will not take it over the maximum size.  If the write 
 would take it over the maximum size, the current log file is backed up to a file in the same folder, with the 
 same extension, named as the original log file is with the currernt date and time appended.  The original log file
 is then emptied and the requested write is performed.</remarks>
</member>
<member name="M:CARE.Access.LogFileWriter.#ctor(System.String,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.LogFileWriter" /> class.
 </summary>
 <param name="path">The path of the active log file.</param>
 <param name="maxBytes">The maximum size of the log file in bytes.</param>
</member>
<member name="M:CARE.Access.LogFileWriter.Write(System.Char[],System.Int32,System.Int32)">
 <summary>
   Writes a subarray of characters to the stream.
 </summary>
 <param name="buffer">A character array containing the data to write.</param>
 <param name="index">The index into <paramref name="buffer" /> at which to begin writing.</param>
 <param name="count">The number of characters to read from <paramref name="buffer" />.</param>
 <exception cref="T:System.ArgumentNullException">
   <paramref name="buffer" /> is null. 
 </exception>
 <exception cref="T:System.ArgumentException">
   The buffer length minus <paramref name="index" /> is less than <paramref name="count" />. 
 </exception>
 <exception cref="T:System.ArgumentOutOfRangeException">
   <paramref name="index" /> or <paramref name="count" /> is negative or <paramref name="count" /> is greater
   than the maximum file size.
  </exception>
  <exception cref="T:System.IO.IOException">
   An I/O error occurs. 
 </exception>
 <exception cref="T:System.ObjectDisposedException">
   <see cref="P:System.IO.StreamWriter.AutoFlush" /> is true or the <see cref="T:System.IO.StreamWriter" /> 
   buffer is full, and current writer is closed. 
 </exception>
 <exception cref="T:System.NotSupportedException">
   <see cref="P:System.IO.StreamWriter.AutoFlush" /> is true or the <see cref="T:System.IO.StreamWriter" /> 
   buffer is full, and the contents of the buffer cannot be written to the underlying fixed size stream because 
   the <see cref="T:System.IO.StreamWriter" /> is at the end the stream.
 </exception>
</member>
<member name="T:CARE.Access.LogFileTraceListener">
 <summary>
 A trace listener to write to a rotatable log file.
 </summary>
</member>
<member name="M:CARE.Access.LogFileTraceListener.#ctor(System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.LogFileTraceListener" /> class.
 </summary>
 <param name="pParameters">The parameters string from the XML.</param>
 <remarks>This constructor is designed to be used by the app</remarks>
</member>
<member name="M:CARE.Access.LogFileTraceListener.#ctor(System.String,System.Int32)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.LogFileTraceListener" /> class.
 </summary>
 <param name="pFilename">The filename of the log.</param>
 <param name="pMaxBYtes">The maximum size of the log in bytes.</param>
</member>
<member name="M:CARE.Access.LogFileTraceListener.Write(System.String)">
 <summary>
 When overridden in a derived class, writes the specified message to the listener you create in the derived class.
 </summary>
 <param name="message">A message to write.</param>
</member>
<member name="M:CARE.Access.LogFileTraceListener.WriteLine(System.String)">
 <summary>
 When overridden in a derived class, writes a message to the listener you create in the derived class, followed by a line terminator.
 </summary>
 <param name="message">A message to write.</param>
 <remarks>This implementation adds the data and time to the message before writing it.</remarks>
</member>
<member name="P:CARE.Access.LogFileTraceListener.IsThreadSafe">
 <summary>
 Gets a value indicating whether the trace listener is thread safe.
 </summary>
 <returns>true if the trace listener is thread safe; otherwise, false. The default is false.</returns>
</member>
<member name="M:CARE.Access.LogFileTraceListener.Dispose(System.Boolean)">
 <summary>
 Releases the unmanaged resources used by the <see cref="T:System.Diagnostics.TraceListener" /> and optionally releases the managed resources.
 </summary>
 <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
</member>
<member name="M:CARE.Access.CountryIbanNumber.GetBankCodeFromIban(System.String)">
 <summary>Gets the Bank Code from the IBAN Number according to the IBAN Country.</summary>
 <returns>The Bank Code portion of the IBAN Number, or an empty string of the IBAN Number is for a different country / insufficient length</returns>
</member>
<member name="M:CARE.Access.CountryIbanNumber.ValidateIbanNumber(System.String)">
 <summary>Validate the IBAN Number according to the MOD 97-10 rule (according to ISO 7064).</summary>
 <param name="pIbanNumber">IBAN number to validate</param>
 <returns>True if IBAN number is valid Else False</returns>
 <remarks>Checks the IBAN number as following:
 Make sure Length is > max length (34 chars)
 Make sure Length is = length specified in country_iban_number
 Make Sure the following:
 Move the four initial characters to the end of the string.
 Replace each letter in the string with two digits, thereby expanding the string, where A=10, B=11, …, Z=35.
 Interpret the string as a decimal integer and apply MOD 97-10 (according to ISO 7064).  
 For the check digits to be correct, the remainder after calculating the modulus 97 must be 1. 
 If the remainder is 1, the check digit test is passed and the IBAN might be valid</remarks>
</member>
<member name="M:CARE.Access.Batch.CreateBatchForTransaction(CARE.Access.Batch.BatchTypes,CARE.Access.PaymentPlan,System.Double,CARE.Access.BatchTransaction@,System.Boolean,System.Boolean)">
 <summary>
 Creates a batch with all associated transactions- batch_transactions, batch_transaction_analysis, order_payment_history, etc. for a Payment Plan payment.
 If a BatchTransaction is supplied this will be used to add any analysis lines to.
 </summary>
 <param name="pBatchType"></param>
 <param name="pPP"></param>
 <param name="pAmount"></param>
 <param name="pBT"></param>
 <param name="pNewBatch"></param>
 <param name="pSaveBatchTransaction"></param>
 <remarks>Currently only credit sales batch types supported</remarks>
</member>
<member name="M:CARE.Access.Batch.ProcessInvoice(CARE.Access.BatchTransaction,CARE.Access.BatchTransactionAnalysis,System.Int32)">
 <summary>Posting invoice payments; creates Invoice Payment History, Invoices and Financial History Details records depending upon the type of invoice payment</summary>
 <param name="pBT">The BatchTransaction record being processed.</param>
 <param name="pBTA">The BatchTransactionAnalysis record being procesed</param>
 <param name="pInvoiceNumber">The number of the invoice being paid</param>
 <remarks>S/L Invoice Payment (line type N) - creates Invoice Payment History, sales ledger Invoice and Financial History Details
 S/L Unallocated Cash (line type U) - creates sales ledger Invoice and Financial History Details
 S/L Allocation of Cash-Invoice (line type L) - creates Financial History Details
 Sundry Credit Note Invoice Allocation (line type K) - creates Financial History Details</remarks>
</member>
<member name="M:CARE.Access.Batch.WriteInvoicePaymentHistory(System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
 <summary>Create an Invoice Payment History record for an Invoice Payment line</summary>
 <param name="pInvoiceNumber">Invoice number of the Invoice being paid</param>
 <param name="pBatchNumber">Batch number of the payment line</param>
 <param name="pTransactionNumber">Transaction number of the payment line</param>
 <param name="pLineNumber">Line number of the payment line</param>
 <param name="pAmount">Amount of invoice payment</param>
</member>
<member name="M:CARE.Access.Batch.WriteInvoicePaymentHistory(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.String,System.Boolean)">
 <summary>Create an Invoice Payment History record for an Invoice Payment line</summary>
 <param name="pInvoiceNumber">Invoice number of the Invoice being paid</param>
 <param name="pBatchNumber">Batch number of the payment line</param>
 <param name="pTransactionNumber">Transaction number of the payment line</param>
 <param name="pLineNumber">Line number of the payment line</param>
 <param name="pAmount">Amount of invoice payment</param>
 <param name="pTransactionDate">Date of the invoice payment</param>
</member>
<member name="M:CARE.Access.Batch.CheckConfirmedTransactionReversal(System.Int32,System.Int32,System.Int32)">
 <summary>
 Checks if the transaction is a reversal of a confirmed order payment transaction
 </summary>
 <param name="pBatchNumber"></param>
 <param name="pTransactionNumber"></param>
 <param name="pLineNumber"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Batch.ProcessLoanDetailsPayment(CARE.Access.BatchTransaction,CARE.Access.BatchTransactionAnalysis,CARE.Access.PaymentPlan,System.Double,System.String)">
 <summary>Assign a Loan payment between the Capital and Interest products.</summary>
 <param name="pBT">BatchTransaction being processed</param>
 <param name="pBTA">BatchTransactionAnalysis being processed</param>
 <param name="pPP">Loan PaymentPlan being processed</param>
 <param name="pAmount">Amount of payment</param>
 <param name="pExpiry">Subscription expiry date</param>
</member>
<member name="M:CARE.Access.Batch.ProcessLoanDetailsReversal(CARE.Access.BatchTransaction,CARE.Access.BatchTransactionAnalysis,CARE.Access.PaymentPlan,System.Double,System.String)">
 <summary>Assign reversal of Loan payment against Capital and Interest products.</summary>
 <param name="pBT">Batchtransaction being processed</param>
 <param name="pBTA">BatchTransactionAnalysis being processed</param>
 <param name="pPP">Loan PaymentPlan being processed</param>
 <param name="pAmount">Reversal payment amount</param>
 <param name="pExpiry">Subscription expiry date</param>
</member>
<member name="M:CARE.Access.Batch.ForceCreationOfRegularProvisionalPayment(CARE.Access.BatchTransaction,CARE.Access.PaymentPlan)">
 <summary>
 Returns True if a new provisional payment record is required on tbhe order payments schedule table.
 </summary>
 <param name="pBatchTransaction"></param>
 <param name="pPaymentPlan"></param>
 <returns></returns>
 <remarks>When the last due payment (provisional) is made for a regular DD paymet a new provisional payemnt must be created.</remarks>
</member>
<member name="P:CARE.Access.Batch.HasInvoices">
 <summary>
 Determines whether any transactions in this batch are associated with an Invoice, Credit Note or Unallocated Payment in Sales Ledger
 </summary>
 <returns>True if any transaction in this batch are linked to an Invoice, Credit Note or Unallocated Payment otherwise false </returns>
 <remarks>It is transactions that are linked to invoices but there can be upto 9999 transactions in a batch so we don't want to ask each transaction</remarks>
</member>
<member name="P:CARE.Access.Batch.HasInvoices(System.Int32)">
 <summary>
 Determines whether a transactions in this batch is associated with an Invoice, Credit Note or Unallocated Payment in Sales Ledger
 </summary>
 <returns>True if tranaction is linked to an Invoice, Credit Note or Unallocated Payment otherwise false </returns>
 <remarks></remarks>
</member>
<member name="T:CARE.Access.BatchTransaction">
 <summary>
 This class is not fully converted to .NET yet
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.BatchTransaction.CanPrintReceipt">
 <summary>Can a Receipt be printed for this transaction?</summary>
</member>
<member name="P:CARE.Access.BatchTransactionAnalysis.HasGiftAidClaim">
 <summary>
 Indicates whether a Gift Aid Claim has already been made for the object.
 </summary>
 <remarks>
 When claim is first made for a BTA line, it is created as an Unclaimed Gift Aid record (declaration_lined_unclaimed)
 Once the claim has been processed, the claim is treated as a Claimed Gift Aid record (declaration_tax_claim_lines)
 Returns TRUE if the BTA line is either Claimed GAD or Unclaimed
 </remarks>
 <returns></returns>
</member>
<member name="P:CARE.Access.BatchTransactionAnalysis.GiftAidableDetailLines">
 <summary>
 Returns all Financial History Detail Lines whose Product is Eligible for Gift-Aid
 </summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.TableMaintenanceData.PreValidateUpdateParameters(CARE.Access.CDBParameters)">
 <summary>
 CARERecord PreValidateUpdateParameters. Called before Update is performed
 </summary>
 <param name="pParameterList"></param>
 <remarks>Add a case statement and call a subroutine to do the validation, don't bloat this with validation code.</remarks>
</member>
<member name="M:CARE.Access.TableMaintenanceData.PreValidateCreateParameters(CARE.Access.CDBParameters)">
 <summary>
 CARERecord PreValidateCreateParameters. Called before Insert is performed
 </summary>
 <param name="pParameterList"></param>
 <remarks>Add a case statement and call a subroutine to do the validation, don't bloat this with validation code.</remarks>
</member>
<member name="M:CARE.Access.TableMaintenanceData.CheckUsedElsewhere(System.String)">
 <summary>
 
 </summary>
 <param name="pContext">pContext may take values of 'D' (deletion) or 'C' (change). An appropriate
 message will be displayed in each case.</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TableMaintenanceData.CanUpdateCPDCycles(CARE.Access.CDBParameters)">
 <summary>When changing a CPD Cycle Type from fixed to flexible or vice versa make sure it's not already in use.</summary>
 <param name="pParams"></param>
 <returns>True if CPD Cycle can be updated, otherwise False</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TableMaintenanceData.ValidateSurveyAnswers(CARE.Access.CDBParameters)">
 <summary>
 Validate Paramaters for Survey Answers
 </summary>
 <param name="pParameterList"></param>
 <remarks>Validation is the same for Update and Create, so only one validation subroutine.</remarks>
</member>
<member name="M:CARE.Access.StandardDocument.SaveEmail(CARE.CDBEmailContent)">
 <summary>
 Saves the email content for this standard document.
 </summary>
 <param name="pEmail">The email.</param>
 <exception cref="T:System.InvalidOperationException">
 Attempt to set the Document property of an uninitialised standard document object
 or
 Attempt to set the Document property of an unsaved standard document object
 or
 Attempt to set the Document property of an email standard document updated no records
 </exception>
</member>
<member name="M:CARE.Access.StandardDocument.SaveAttachment(CARE.CDBEmailAttachment)">
 <summary>
 Saves the an attachment linked to this standard document attachment.
 </summary>
 <param name="pNewAttachment">The new attachment.</param>
 <exception cref="T:System.ArgumentNullException">pNewAttachment</exception>
 <exception cref="T:System.InvalidOperationException">Specified attachement does not exist</exception>
 <remarks>If the supplied <see cref="T:CARE.CDBEmailAttachment"/> contains an ID, it is assumed to be an 
 existing attachment and just a link is created.  If not, the attachment is saved as a new attachment
 and the link is created to that.</remarks>
</member>
<member name="M:CARE.Access.StandardDocument.GetEmail">
 <summary>
 Gets the email content for this standard document.
 </summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.StandardDocument.DeleteAttachments">
 <summary>
 Deletes the attachments for this standard document.
 </summary>
</member>
<member name="P:CARE.Access.MembershipEntitlement.Priority">
 <summary>No Longer Supported.</summary>
</member>
<member name="M:CARE.Access.MembershipType.SetUserDefinedFirstPeriodsProductRate(CARE.Access.ProductRate)">
 <summary>Sets the UserDefinedFirstRate and validates the internal First Periods Product and Rate codes.</summary>
 <param name="pFirstProductRate">ProductRate containing the Product and Rate to be used for the first period</param>
 <remarks>Only used by Renewals and Reminders to handle situation where both the Product and Rate have been changed.</remarks>
</member>
<member name="M:CARE.Access.MembershipType.SetUserDefinedSubsequentPeriodsProductRate(CARE.Access.ProductRate)">
 <summary>Sets the UserDefinedSubsequentRate and validates the internal Subsequent Periods Product and Rate codes.</summary>
 <param name="pSubsequentProductRate">ProductRate containing the Product and Rate to be used for the subsequent period</param>
 <remarks>Only used by Renewals and Reminders to handle situation where both the Product and Rate have been changed.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateCMTTerm(System.DateTime,CARE.Access.PaymentFrequency,System.DateTime@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Boolean@)">
 <summary>Calculate the number of months for the old and new membership types.</summary>
 <param name="pCMTDate">Date the prorating will be effective.</param>
 <param name="pNewPayFrequency">The new PaymentFrequency. Only used when prorating is by frequency amounts.</param>
 <param name="pJoinedDate">The members joined date.</param>
 <param name="pChargeTermMonths">The total number of months to be charged for.</param>
 <param name="pFullTermMonths">The total number of months in the current renewal period.</param>
 <param name="pOldTypeMonths">The number of months applicable for the old membership type.</param>
 <param name="pNewTypeMonths">The number of months applicable or the new membership type.</param>
 <param name="pUseProrateMonths">Boolean flag indicating whether to use <paramref name="pChargeTermMonths">pChargeTermMonths</paramref>.</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.RemoveCMTLines(CARE.Access.PaymentPlanDetail.PaymentPlanDetailTypes,System.String,System.Boolean,System.Boolean)">
 <summary>Remove detail lines for the old membership type.</summary>
</member>
<member name="P:CARE.Access.PaymentPlan.CanProrateCMTBalance(CARE.Access.MembershipType)">
 <summary>Can the PaymentPlan Balance be prorated by CMT?</summary>
 <param name="pNewMembershipType">The MembershipType to change to.</param>
</member>
<member name="P:CARE.Access.PaymentPlan.CanUseAdvancedCMT(CARE.Access.MembershipType)">
 <summary>Can this PaymentPlan go through an Advanced CMT?</summary>
 <param name="pNewMembershipType">The MembershipType to change to.</param>
</member>
<member name="M:CARE.Access.PaymentPlan.GetCMTOPSCreationDate">
 <summary>Gets the payment schedule creation date for Change Membership Type (CMT).</summary>
 <returns>Payment schedule creation date.</returns>
 <remarks>When running in multiple-CMT mode the payment schedule creation date will differ
 depending upon whether this is the first or second CMT.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.SumWriteOffAmounts(System.String,System.String)">
 <summary>Used by Change Membership Type to calculate how much was written off during the specified period.</summary>
 <param name="pStartDate">Renewal period start date</param>
 <param name="pRenewalDate">Renewal period end date</param>
 <returns>Amount written off during the specified period.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.CanChangeCMTDDPayer(CARE.Access.Member,System.String,CARE.Access.MembershipType,CARE.Access.Contact@)">
 <summary>Can the change of membership type for a Member allow the Direct Debit payer to change?</summary>
 <param name="pMember">The <see cref="P:CARE.Access.PaymentPlan.Member">Member</see> having the membership type changed.</param>
 <param name="pCancellationReasonCode">The cancellation reason code for the change of membership type.</param>
 <param name="pNewMembershipType">The new <see cref="P:CARE.Access.PaymentPlan.MembershipType">MembershipType</see> for the chosen Member.</param>
 <param name="pNewDDPayer">The <see cref="T:CARE.Access.Contact">Contact</see> that will become the new Direct Debit payer. This will either be set to a valid <see cref="T:CARE.Access.Contact">Contact</see> or Nothing.</param>
 <returns>True if the Direct Debit payer can be changed, otherwise False.</returns>
 <remarks>This is a subset of <see cref="M:CARE.Access.PaymentPlan.CanChangeMemberDDPayer(CARE.Access.Member,System.String,CARE.Access.Contact@)">CanChangeMemberDDPayer</see> to perform the additional checks required by Change Membership Type.</remarks>
</member>
<member name="T:CARE.Access.PaymentPlan.ppAutoPayMethods">
 <summary>
 The enumerations for Auto Pay Methods
 </summary>
 <remarks></remarks>
</member>
<member name="F:CARE.Access.PaymentPlan.ppAutoPayMethods.ppAPMSO">
 <summary>
 Standing Order
 </summary>
</member>
<member name="F:CARE.Access.PaymentPlan.ppAutoPayMethods.ppAPMDD">
 <summary>
 Direct Debit
 </summary>
</member>
<member name="F:CARE.Access.PaymentPlan.ppAutoPayMethods.ppAPMCCCA">
 <summary>
 Continuous Credit Card Authority
 </summary>
</member>
<member name="P:CARE.Access.PaymentPlan.MembershipNumber">
 <summary>
 The membership number if the plan is a membership.
 </summary>
 <value>
 The membership number.
 </value>
 <remarks>For a payment plan that is not a membership plan, the value of this proerty is undefined.  The member property
 of this class is referenced to ensure that the member details are initialised.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.Cancel(System.Int32@,CARE.Access.PaymentPlan.PaymentPlanCancellationTypes@,System.String@,System.String@,System.String@,System.String@,System.String@,System.Int32,System.Int32@,System.String,System.Boolean,System.Boolean,System.String)">
 <summary>
 Cancels the specified payment plan.
 </summary>
 <param name="pMembershipNumber">The membership number</param>
 <param name="pType">Type of cancelation</param>
 <param name="pCancellationReason">The cancellation reason</param>
 <param name="pStatus">The status.</param>
 <param name="pCancellationReasonDesc">The cancellation reason description</param>
 <param name="pLogname">The logname</param>
 <param name="pCancellationSource">The cancellation sourc.</param>
 <param name="pBatchNumber">The batch number</param>
 <param name="pTransactionNumber">The transaction number</param>
 <param name="pStatusDate">The status date</param>
 <param name="pUpdateDetailsSource">if set to <c>true</c> [update details source]</param>
 <param name="pRemoveFixedAmount">if set to <c>true</c> [remove fixed amount]</param>
 <param name="pCancellationDate">The cancellation date</param>
 <remarks>This overload of the <see cref="M:CARE.Access.PaymentPlan.Cancel(CARE.Access.PaymentPlan.PaymentPlanCancellationTypes@,System.String@,System.String@,System.String@,System.String@,System.String@,System.Int32,System.Int32@,System.String,System.Boolean,System.Boolean,System.String)">Cancel</see>method should be used if the cancelation may be for a 
 membership.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlan.OrderNumber">
 <summary>
 The order number associated with this payment plan.
 </summary>
</member>
<member name="P:CARE.Access.PaymentPlan.TermStartDate">
 <summary>The current term start date of the payment plan.</summary>
 <remarks>If renewal pending and the renewal date is on or before today, the renewal date is the start date of the term, 
 otherwise it is the renewal date minus the length of the term.
 <see cref="M:CARE.Access.PaymentPlan.CalculateRenewalDate(System.String,System.Boolean)">CalulateRenewalDate</see> is used the perform the calculation of the result in the second case.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlan.TermEndDate">
 <summary>The current term end date of the payment plan.</summary>
 <remarks>If renewal pending and the renewal date is on or before today, the renewal date is the end date of the term, 
 otherwise it is the renewal date plus the length of the term.
 <see cref="M:CARE.Access.PaymentPlan.CalculateRenewalDate(System.String,System.Boolean)">CalulateRenewalDate</see> is used the perform the calculation of the result in the first case.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlan.ScheduledPayments(System.Boolean)">
 <summary>Select all payment schedule records and add to the mvScheduledPayments collection.</summary>
 <param name="pAllDuePayments">Set to True to only select payments that are Due/Part-Paid/Unpaid/Provisional, otherwise set to False.  Defaults to True.</param>
 <returns>Collection containing all selected payment scheduled records.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.GetProrataBalance(System.Double,System.String,System.Boolean,CARE.Access.ProductRate,CARE.Access.VatRate,System.Int32,System.Double,System.Double,System.Double@,System.String,System.Boolean)">
 <summary>Calculate the pro-rated amount for pPrice.</summary>
 <param name="pPrice">The amount to be pro-rated.</param>
 <param name="pJoinDate">The membership joined date or, if not a membership, the pro-rating start date.</param>
 <param name="pFromRenewals">Has this come from Renewals?</param>
 <param name="pRate">The ProductRate object for the amount to be pro-rated.</param>
 <param name="pVATRate">The VATRate object used to calculate VAT for VAT-exclusive rates.</param>
 <param name="pContactNumber">Contact number used for rate modifiers.</param>
 <param name="pQuantity">The number of items this price relates to.</param>
 <param name="pSourceDiscountPercentage">The discount percentage, if any, to be applied based upon the source code.</param>
 <param name="pNetAmount">The pro-rated net price (i.e. without VAT).</param>
 <param name="pStartDate">The membership start date used when creating a new membership.</param>
 <param name="pNewDetailLine">Is a new detail line being added?</param>
 <returns>Pro-rted price.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.GetScheduledPayments(System.Boolean,System.String,System.Boolean,System.Boolean)">
 <summary>Get the Order Payment Schedule records for the current term only</summary>
 <param name="pAllDuePayments">Set to True to only select payments that are Due/Part-Paid/Unprocessed-Payment/Provisional, otherwise set to False.  Defaults to True.</param>
 <param name="pOverrideRenewalDate">Over-ride the calculated RenewalDate with this value when pAllDuePayments is False.</param>
 <param name="pSkipProcessing">Skipping payments</param>
 <param name="pCreateInAdvancePayments">Regenerating OPS for opscrInAdvance</param>
</member>
<member name="M:CARE.Access.PaymentPlan.GetEarliestDueOPS">
 <summary>Get the earliest OPS with status of Due, PartPaid or Provisional</summary>
 <returns>Earliest OPS</returns>
 <remarks>Called from RegeneratePaymentSchedule for PPMaintenance</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.GetLatestOrEarliestDueOPS(System.Boolean,System.String,System.String)">
 <summary>Set the ScheduledPayments collection with latest or earliest OPS with status of Due, PartPaid, Provisional or Unprocessed Payment</summary>
 <remarks>Called from AutoSOReconciliation for NI Number Reconciliation</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.WriteOffMissedPayments(System.DateTime)">
 <summary>Write Off missed payment schedule payments.</summary>
 <param name="pChangeDate">Date of change - payments must be older than this date to be written off.</param>
 <returns>Returns the amount written off.</returns>
 <remarks>Payments due on or before the payment date plus over-due days will be written off.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.WriteOffMissedPayments(CARE.Access.CDBParameters,CARE.Access.PaymentFrequency,System.DateTime,System.Boolean)">
 <summary>Write Off missed payment schedule payments.</summary>
 <param name="pOrigPaymentFrequency">Original PaymentFrequency before any change.</param>
 <param name="pChangeDate">Date of change - payments must be older than this date to be written off.</param>
 <param name="pIsCMT">Is this Change Membership Type?</param>
 <returns>Returns the amount written off.</returns>
 <remarks>Payments due on or before the payment date plus over-due days will be written off.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.GetProRataMonthsRemaining(System.Int32,System.DateTime,System.DateTime)">
 <summary>Gets the number of months from pChangeDate to pRenewalPeriodEnd, taking into account the AutoPayAdvancePeriod days.</summary>
 <param name="pFullTermMonths">The total number of months in the current renewal period</param>
 <param name="pChangeDate">Date of change</param>
 <param name="pRenewalPeriodEnd">Date of end of the renewal period</param>
 <returns>The number of months.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.SetWriteOffRequired(System.Boolean)">
 <summary>Sets whether missed payments need to be written off when maintaining a Payment Plan through Data Import.</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.ReCalculateFrequencyAmount(System.Double)">
 <summary>Re-calculate the FrequencyAmount based upon the current RenewalAmount and PaymentFrequency</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.UpdateOneYearGift(System.Boolean)">
 <summary>Updates the one_year_gift flag for gifted non group membership</summary>
</member>
<member name="P:CARE.Access.PaymentPlan.DetailsContainPricingInfo(CARE.Access.PaymentPlanDetail.PaymentPlanDetailTypes)">
 <summary>Gets a boolean flag indicating whether any Payment Plan Details of the specified type have pricing information set on them.</summary>
 <param name="pDetailTypes">The PaymentPlanDetailTypes to check</param>
 <returns>True if any of the Detail lines contain pricing information, otherwise False</returns>
 <remarks>This is being used by CMT only.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlan.TermLength">
 <summary>Gets the length of the renewal term appropriate for the term units.</summary>
 <returns>Number of weeks for term units of weekly, otherwise the number of months.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.IsUpdateAfterRenewal(CARE.Access.OrderPaymentSchedule.OrderPaymentScheduleCreationReasons,System.DateTime,System.DateTime)">
 <summary>Is this an update to the Payment Plan after Renewals / Reminders has been run but before the renewal date has been reached?</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.GetLatestDueOPS(System.String)">
 <summary>Get the latest OPS with status of Due, PartPaid or Provisional due before pRenewalDate</summary>
 <returns>Latest OPS</returns>
 <remarks>Called from DeleteOPSForRegenerate for PPMaintenance</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.GetNextInstalmentDueDate(System.DateTime)">
 <summary>Gets the change date to use when the payment frequency has changed.</summary>
 <param name="pChangeDate">Date the change is to take effect.</param>
 <remarks>Used by Payment Plan Maintenance to decide what the next instalment date will be when the Payment Frequency has changed.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CheckOPSMinDeleteDate(System.String,System.String,System.DateTime)">
 <summary>When re-creating the payment schedule for CMT or PPMaintenance check if the next ClaimDate is after the minimum delete date.</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.UpdateFromAutoPayStartDate">
 <summary>Updates the payment plan and OPS on changing the auto payment method start date.</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.CanChangeMemberDDPayer(CARE.Access.Member,System.String,CARE.Access.Contact@)">
 <summary>Can the cancellation of a Member allow the Direct Debit payer to change?</summary>
 <param name="pMember">The <see cref="P:CARE.Access.PaymentPlan.Member">Member</see> being cancelled.</param>
 <param name="pCancellationReasonCode">The cancellation reason code for the cancellation.</param>
 <param name="pNewDDPayer">The <see cref="T:CARE.Access.Contact">Contact</see> that will become the new Direct Debit payer. This will either be set to a valid <see cref="T:CARE.Access.Contact">Contact</see> or Nothing.</param>
 <returns>True if the Direct Debit payer can be changed, otherwise False.</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.ValidateChangeDDPayer(CARE.Access.Member,CARE.Access.Contact@,System.String,System.Nullable{System.Boolean}@,System.Int32,CARE.Access.MembershipType)">
 <summary>Used by Member cancellation and Change Membership Type to determine whether the Direct Debit payer can be changed.</summary>
 <param name="pMember">Current <see cref="P:CARE.Access.PaymentPlan.Member">Member</see> record.</param>
 <param name="pNewDDPayer">The <see cref="T:CARE.Access.Contact">Contact</see> that will become the new Direct Debit payer. This will either be set to a valid <see cref="T:CARE.Access.Contact">Contact</see> or Nothing.</param>
 <param name="pCancellationReason">Member cancellation reason.</param>
 <param name="pChangeDDPayer">User instruction on whether Direct Debit payer can be changed.</param>
 <param name="pDirectDebitNewPayerContactNumber">User chosen new Direct Debit payer contact number.</param>
 <param name="pCMTMembershipType"><see cref="P:CARE.Access.PaymentPlan.MembershipType">MembershipType</see> to change to. Only used by Change Membership Type.</param>
</member>
<member name="M:CARE.Access.PaymentPlan.GetProvisionalOPSDueDate(System.DateTime)">
 <summary>Get the payment schedule due date taking into account any offset months on the <seealso cref="T:CARE.Access.PaymentFrequency">PaymentFrequency</seealso>.</summary>
 <param name="pDueDate">Calculated due date.</param>
 <returns>Due date taking into account any offset months</returns>
</member>
<member name="P:CARE.Access.PaymentPlan.AutoPayBankAccount">
 <summary>Gets the <see cref="T:CARE.Access.BankAccount"/> for the auto payment method.</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.GetAutoPaymentDefaultStartDate(System.DateTime,CARE.Access.PaymentPlan.ppAutoPayMethods,CARE.Access.BankAccount,System.String,System.Nullable{System.DateTime},System.String,System.Nullable{System.Int32})">
 <summary>Gets the default auto payment start date.</summary>
 <param name="pBaseDate">The base date the calculations will use.  E.g. Plan start date.</param>
 <param name="pAutoPayMethod">The type of auto payment method.</param>
 <param name="pBankAccount">The <see cref="T:CARE.Access.BankAccount"/> for the auto payment method.</param>
 <param name="pMembershipTypeCode">Used when creating a membership. The membership type being created.</param>
 <param name="pMemberJoinedDate">Used when creating a membership. The members joined date.</param>
 <param name="pTransactionType">The Trader transaction-type code.</param>
 <param name="pStartMonth">Used when creating subscriptions and regular donations. This is the month the Payment Plan and any auto payment method tarts</param>
 <returns>Calculated default start date for the auto payment method.</returns>
 <remarks>Class must have been initialised prior to calling this method.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.AddLoan(CARE.Access.CDBParameters)">
 <summary>Add a Loans record to the Payment Plan.</summary>
 <param name="pParams">CDBParameters collection containing Loan details</param>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateLoanInterest(System.String,System.Boolean)">
 <summary>Calculate the interest on the Loan from the calculation date to the end of the Loan.</summary>
 <remarks>This also re-creates the payment schedule</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateLoanInterest(System.String,System.Boolean,System.String)">
 <summary>Calculate the interest on the Loan from the calculation date to the end of the Loan.</summary>
 <remarks>This also re-creates the payment schedule</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateLoanInterest(System.String,System.Boolean,System.String,System.Boolean)">
 <summary>Calculate the interest on the Loan from the calculation date to the end of the Loan.</summary>
 <remarks>This also re-creates the payment schedule</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateLoanPaymentInterest(System.DateTime,System.DateTime,System.Double)">
 <summary>Calculate the interest this Loan payment includes.</summary>
 <param name="pDateOfLastPayment">The date the previous payment was received.</param>
 <param name="pPaymentDate">The date this payment was received.</param>
 <param name="pLoanAmount">The loan amount that has accrued interest</param>
 <returns>The interest payable by this payment.</returns>
 <remarks>If pPaymentDate is before pDateOfLastPayment then zero will be returned.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.CalculateLoanPaymentInterest(System.DateTime,System.DateTime,System.Double,System.Double)">
 <summary>Calculate the interest this Loan payment includes.</summary>
 <param name="pDateOfLastPayment">The date the previous payment was received.</param>
 <param name="pPaymentDate">The date this payment was received.</param>
 <param name="pLoanAmount">The loan amount that has accrued interest</param>
 <param name="pInterestRate">The Interest Rate to use for the calculations</param>
 <returns>The interest payable by this payment.</returns>
 <remarks>If pPaymentDate is before pDateOfLastPayment then zero will be returned.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.DeleteLoanScheduledPayments(System.DateTime)">
 <summary>Delete all unpaid Loan scheduled payments dated on or after the deletion date.</summary>
 <param name="pDeletionDate">The date the payments are to be deleted from</param>
</member>
<member name="M:CARE.Access.PaymentPlan.SetLoanFrequencyAmount">
 <summary>Set the FrequencyAmount based upon the Loan Term and Payment Amount.</summary>
</member>
<member name="P:CARE.Access.PaymentPlan.LoanLastPaymentDate">
 <summary>Gets the transaction date of the last loan payment.</summary>
 <returns>The date of the last payment, if set, otherwise the Loan start date</returns>
</member>
<member name="M:CARE.Access.PaymentPlan.GetLoanPaymentOPS(System.DateTime)">
 <summary>Gets the Payment Schedule data for Loan payments.</summary>
 <param name="pTransactionDate">The transaction date of the payment</param>
 <remarks>Used by Trader to find the payment schedule record to allocate the payment against.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlan.RegenerateLoanScheduledPayments(System.String,System.Boolean)">
 <summary>Regenerate the Scheduled Payments for a Loan.</summary>
</member>
<member name="M:CARE.Access.PaymentPlan.AddLoanFromDataRow(System.Data.DataRow,System.Boolean)">
 <summary>Initialise the Loan object from the DataRow for a Loan PaymentPlan.</summary>
</member>
<member name="M:CARE.Access.CARERecord.GetFirstDeleteCheckItem">
 <summary>
 Runs through the list of DeleteCheckItems and returns the first one that fails.  The DeleteCheckItems are set up at the derived class by calling AddDeleteCheckItem.  If none fail then it returns Nothing.
 </summary>
 <returns>DeleteCheckItem class representing the table and attribute for the relationship that fails.</returns>
 <remarks>This is an overridable method that is called by the Delete method.  In most cases it will be sufficient to check for dependent records by using AddDeleteCheckItem.
 If however the check has to be more complex then this method can be overridden.
 </remarks>
</member>
<member name="M:CARE.Access.CARERecord.Save(System.String,System.Boolean,System.Int32,System.Boolean)">
 <summary>
 Save with amendment history
 </summary>
 <param name="pAmendedBy"></param>
 <param name="pAudit"></param>
 <param name="pJournalNumber"></param>
 <param name="pForceAmendmentHistory"></param>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.CARERecord.Environment">
 <summary>
 The <see cref="T:CARE.Access.CDBEnvironment"/> object associated with this entity
 </summary>
 <value>The <see cref="T:CARE.Access.CDBEnvironment"/> object associated with this entity</value>
 <returns>The <see cref="T:CARE.Access.CDBEnvironment"/> object associated with this entity</returns>
</member>
<member name="M:CARE.Access.CARERecord.CreateWhere(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Return a CDBFields class containing the field name and value of every field index that is passed
 </summary>
 <param name="pFieldIndexes">A list(Of Integer) of all field indexes that are to be included in the CDBFields clause</param>
 <returns>This method is useful when a record needs to be queried that matches the values of a composite key stored in the current object</returns>
</member>
<member name="M:CARE.Access.CARERecord.CreateParams(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Returns a CDBParameters instance with the values of your class for the field indexes that you pass.
 </summary>
 <param name="pFieldIndexes">An IEnumerable of the Fields indexes used to access the ClassFields property</param>
 <example>
 Dim vGAClaimLine as DeclarationLinesUnclaimed = Me.GetRelatedInstance(Of DeclarationLinesUnclaimed)({BatchTransactionAnalysisFields.BatchNumber, BatchTransactionAnalysisFields.TransationNumber, BatchTransactionAnalysisFields.LineNumber}) 'Try to get the instance before you create it
 If vGAClaimLine Is Nothing Then vGAClaimline = New DeclarationLinesUnclaimed(Me.Environment)
 vGAClaimLine.Create(Me.CreateParams({BatchTransactionAnalysisFields.BatchNumber, BatchTransactionAnalysisFields.TransationNumber, BatchTransactionAnalysisFields.LineNumber}) 'Initialise the new class with the values from my class
 </example>
 <returns>an instance of the CDBParameters class with the values from your class</returns>
</member>
<member name="M:CARE.Access.CARERecord.GetRelatedInstance``1(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Returns an instance of T with the values within the fields specified by the pRelatedFieldIndexes parameter
 </summary>
 <typeparam name="T">The CARERecord type that you want </typeparam>
 <param name="pRelatedFieldIndexes">An IEnumerable of the Fields indexes used to access the ClassFields property</param>
 <remarks>
 This method will create a CDBFields instance with the fields and values specified in the pRelatedFieldIndexes parameter
 It will then try to instantiate your class by calling InitWithPrimaryKey.  If the CARERecord.Existing returns True then
 the return will be the instance.  If it is False then the return will be Nothing
 </remarks>
 <returns>The CARERecord that you have specified if it exists</returns>
</member>
<member name="M:CARE.Access.CARERecord.GetList``1(CARE.Data.CDBFields)">
 <summary>
 Returns an IList of the CARERecord type you have specified for the values that match the CDBFields you have specified
 </summary>
 <typeparam name="T">The CARERecord Type that you want as a collection</typeparam>
 <param name="pWhere">The CDBFields that you want the CARERecord instances to match</param>
 <returns>an IList of the CARERecord Type that you want</returns>
</member>
<member name="M:CARE.Access.CARERecord.GetRelatedList``1(System.Collections.Generic.IEnumerable{System.Int32})">
 <summary>
 Returns a List of CARERecords with the values within the fields specified by the pRelatedFieldIndexes parameter
 </summary>
 <typeparam name="T">The CARERecord type that you want as a collection</typeparam>
 <param name="pRelatedFieldIndexes">An IEnumerable of the Fields indexes used to access the ClassFields property</param>
 <remarks>
 This method will create a Where clause as a CDBFields instance with the fields and values specified in the pRelatedFieldIndexes parameter.
 It will then try to instantiate your list by calling GetDataTable() and then running an InitFromDataRow for each row in the DataTable.
 The List will only contain the records that match the values you have passed.
 </remarks>
 <returns>A List of the CARERecords that match the values in your class.  If no record matches the values then the list will be empty.</returns>
</member>
<member name="P:CARE.Access.CARERecord.ClassFields">
 <summary>
 The Property accessor for the mvClassFields member variable.  Use this instead of accessing the member variable directly.
 </summary>
 <returns></returns>
</member>
<member name="P:CARE.Access.CARERecord.Relations">
 <summary>
 
 </summary>
 <returns>Collection of MaintenanceRelation that have this CARERecod as their Primary Table in table Maintenance_Relations</returns>
</member>
<member name="M:CARE.Access.CARERecord.CheckUsedElsewhere(CARE.Access.ClassFields)">
 <summary>
 Will check to see if this record has related records on other tables. Uses maintenence_relations table. 
 If a record is found an exception is raised. Intended to stop the creation of orphans when deleting a CARERecord.
 </summary>
 <param name="pClassFields"> The ClassFields for this CARERecord usually mvClassFields</param>
</member>
<member name="M:CARE.Access.CDBControl.SetControlWidth">
 <summary>
 Adjusts the length of the text control and its caption
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.CDBEnvironment.CheckInvoiceControlNumbers(System.Data.DataTable)">
 <summary>
 Check to see if Provisional Invoice control number is more than 10,000 greater than the invoice control number. Warn if not.
 </summary>
 <param name="pDataTable">datatable of table control_numbers</param>
 <returns>Appropriate Warning message or an empty string</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.CDBEnvironment.GetPaymentPlanAutoPayDate(System.DateTime,CARE.Access.PaymentPlan.ppAutoPayMethods,CARE.Access.BankAccount)">
 <summary>Calculates and returns the auto payment date.</summary>
 <param name="pDate">The base date used for the calculations.</param>
 <param name="pAutoPayMethod">The type of auto payment method.</param>
 <param name="pBankAccount">The BankAccount for the auto payment method.</param>
 <returns>The calculated date based upon the pAutoPayMethod and the number of working days.</returns>
</member>
<member name="M:CARE.Access.CDBEnvironment.GetPaymentPlanAutoPayDate(System.DateTime,CARE.Access.PaymentPlan.ppAutoPayMethods,CARE.Access.BankAccount,System.Boolean)">
 <summary>Calculates and returns the auto payment date.</summary>
 <param name="pDate">The base date used for the calculations.</param>
 <param name="pAutoPayMethod">The type of auto payment method.</param>
 <param name="pBankAccount">The BankAccount for the auto payment method.</param>
 <param name="pGetAutoPayAdvancePeriod">Set to True to use the Membership Controls 'Auto Pay Advance Notice Period', otherwise False to use the current configuration for the auto pay delay days.</param>
 <returns>The calculated date based upon the pAutoPayMethod and the number of working days.</returns>
</member>
<member name="T:CARE.Access.CDBEnvironment.ppType">
 <summary>
 The enumerations for Payment Plan Types used by AddPaymentPlan
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.CDBEnvironment.CheckIbanNumber(System.String)">
 <summary>Checks the IBAN number for validitity.</summary>
 <param name="pIbanNumber">Iban number to validate</param>
 <returns>True if IBAN number is valid else False</returns>
</member>
<member name="P:CARE.Access.CDBDataTable.ListManagerViewSelection">
 <summary>Gets or sets boolean flag indicating whether this is selecting data for List Manager</summary>
</member>
<member name="P:CARE.Access.CDBUser.Logname">
 <summary>The Logname of the user in the Users table in the database. 
 When using Web Services this will be set to the Logname supplied to the Web Service, defaulting to guest. 
 The Logname should NOT be used for setting attributes such as amended_by, instead use the <see cref="P:CARE.Access.CDBUser.UserID">UserID</see>.</summary>
</member>
<member name="P:CARE.Access.CDBUser.UserID">
 <summary>The ID of the current user which may be different to the <see cref="P:CARE.Access.CDBUser.Logname">Logname</see>.
 The Smart Client will set the UserID to the same as the Logname, whilst Web Services will set it to the value passed into the Web Service.
 This should always be used when setting attributes such as amended_by.</summary>
</member>
<member name="M:CARE.Access.CDBUser.OwnershipSelect(System.String,System.Boolean,System.String,System.Boolean)">
 <summary>Build the Ownership SQL.</summary>
 <param name="pAlias">Table alias to use.  E.g. c for contacts, o for organisations.</param>
 <param name="pTables">Only add the required table names to the SQL.</param>
 <param name="pPrnDept">Restrict the ownership_groups principal department to this value. Only used when <paramref name="pAccessLevelOnly"/> is True.</param>
 <param name="pAccessLevelOnly">Only check access levels.</param>
 <returns></returns>
</member>
<member name="M:CARE.Access.CDBUser.OwnershipSelect(System.String,System.String,System.Boolean,CARE.Data.AnsiJoins@,CARE.Data.CDBFields@)">
 <summary>Build the Ownership SQL.</summary>
 <param name="pAlias">Table alias to use.  E.g. c for contacts, o for organisations.</param>
 <param name="pPrnDept">Restrict the ownership_groups principal department to this value. Only used when <paramref name="pAccessLevelOnly"/> is True.</param>
 <param name="pAccessLevelOnly">Only check access levels.</param>
 <param name="pAnsiJoins"></param>
 <param name="pWhereFields"></param>
</member>
<member name="M:CARE.Access.ClassFields.Save(CARE.Access.CDBEnvironment,System.Boolean@,System.String,System.Boolean,System.Int32,System.Boolean)">
 <summary>
 SAve with amendment history
 </summary>
 <param name="pEnv"></param>
 <param name="pExisting"></param>
 <param name="pAmendedBy"></param>
 <param name="pAudit"></param>
 <param name="pJournalNumber"></param>
 <param name="pForceAmendmentHistory"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.OrderByClause(System.Collections.Generic.Dictionary{CARE.Access.ClassField,CARE.Access.ClassFields.OrderByDirection})">
 <summary>
 Builds a string that can be used as an Order By clause in a SQL Statement from a collection of ClassFields and OrderByDirection pairs
 </summary>
 <param name="pOrderByItems">The dictionary of ClassField and OrderByDirection items.</param>
 <returns>an Order By string made up of the database name of each class field and the order by direction.</returns>
</member>
<member name="T:CARE.Access.ClassFields.AmendmentHistoryCreation">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.CreateAmendmentHistory(CARE.Access.CDBEnvironment,CARE.Access.ClassFields.AmendmentHistoryCreation)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.ClearSetValues">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.SetUniqueFieldsFromPrimaryKeys">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.Delete(CARE.Data.CDBConnection)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.Delete(CARE.Data.CDBConnection,CARE.Access.CDBEnvironment,System.String,System.Boolean)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.Save(CARE.Access.CDBEnvironment,System.Boolean@)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ClassFields.Save(CARE.Access.CDBEnvironment,System.Boolean@,System.String,System.Boolean)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.ClassFields.ItemDataType(System.String)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.ClassFields.ItemValue(System.String)">
 <summary>
 SHOULD ONLY USED BY VB6 MIGRATEDCODE
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.CommunicationsLog.SaveEmail(CARE.CDBEmailContent)">
 <summary>
 Saves the email content for this communications log.
 </summary>
 <param name="pEmail">The email.</param>
 <exception cref="T:System.InvalidOperationException">
 Attempt to set the Document property of an uninitialised coummunications log object
 or
 Attempt to set the Document property of an unsaved coummunications log object
 or
 Attempt to set the Document property of an email coummunications log updated no records
 or
 Attempt to update the Document property of an email coummunications log that already contains data
 </exception>
</member>
<member name="M:CARE.Access.CommunicationsLog.SaveAttachment(CARE.CDBEmailAttachment)">
 <summary>
 Saves the an attachment linked to this communicaitons log attachment.
 </summary>
 <param name="pNewAttachment">The new attachment.</param>
 <exception cref="T:System.ArgumentNullException">pNewAttachment</exception>
 <exception cref="T:System.InvalidOperationException">Specified attachement does not exist</exception>
 <remarks>If the supplied <see cref="T:CARE.CDBEmailAttachment"/> contains an ID, it is assumed to be an 
 existing attachment and just a link is created.  If not, the attachment is saved as a new attachment
 and the link is created to that.</remarks>
</member>
<member name="M:CARE.Access.CommunicationsLog.GetEmail">
 <summary>
 Gets the email content for this communications log.
 </summary>
 <returns></returns>
</member>
<member name="M:CARE.Access.CommunicationsLog.DeleteAttachments">
 <summary>
 Deletes the attachments for this communnications log.
 </summary>
</member>
<member name="M:CARE.Access.Contact.ValidateHonorifics(System.String)">
 <summary>
 Returns an ordered, space-delimited string of honorifics
 </summary>
 <param name="pValue">The un-ordered, space-delimited string of honorifics</param>
 <returns>String</returns>
 <remarks>The returned honorifics are ordered by the sequence number recorded against their record.
 If an honorific is passed that is not recognised by the system, it will be removed from the list.
 This method only processes data if the cd_validate_honorifics config is active
 </remarks>
</member>
<member name="P:CARE.Access.Contact.DefaultLabelNameFormatCode">
 <summary>
 This property is set by the SetLabel method.  Please ensure that SetLabel is called once at least before you access is.
 </summary>
 <returns></returns>
 <remarks>Setting a member variable in a method is not considered best practice.  However, this is how the code was written</remarks>
 Don't blame me I only work here :)
</member>
<member name="M:CARE.Access.Contact.DeleteMergedContact(System.String,System.Boolean,System.Int32)">
 <summary>Delete the Contact following a Contact Merge.</summary>
 <remarks>This method does NOT check data or delete other related data.
  It must only be called after a merge when we know all related data has been moved.</remarks>
</member>
<member name="M:CARE.Access.Contact.DoContactCommunicationsDeDup(CARE.Data.CDBConnection,System.Int32,System.Int32)">
 <summary>
 De duplicate communications BR14606
 </summary>
 <param name="pConn">The database connection</param>
 <param name="pPContactNumber">The primary contact</param>
 <param name="pDContactNumber">The duplicate contact</param>
 <remarks>Does not merge. Ensures that there is only one default device per device</remarks>
</member>
<member name="M:CARE.Access.Contact.DeleteDuplicateContactAddress(CARE.Access.JobSchedule@,CARE.Data.CDBConnection,System.Int32,System.Int32)">
 <summary>
 If changing a duplicate contacts address to the target address would result in an attempt to create a duplicate contact address record, then delete the duplicate.
 </summary>
 <param name="pJob"></param>
 <param name="pConn"></param>
 <param name="pAddTo">Target Address</param>
 <param name="pAddFrom">Duplicate Address</param>
 <remarks>address_number and contact_number are a unique combination on contact_addresses BR15454</remarks>
</member>
<member name="P:CARE.Access.CDBEvent.HasActions">
 <summary>Does this <see cref="T:CARE.Access.CDBEvent">Event</see> have any Actions linked to it?</summary>
 <returns>True if the Event has Actions linked to it, otherwise False</returns>
</member>
<member name="P:CARE.Access.CDBEvent.CalculateTotalsErrorCount">
 <summary>The total number of attributes that could not be updated when using CalculateTotals.</summary>
</member>
<member name="P:CARE.Access.CDBEvent.CalculateTotalsErrorFields">
 <summary>The names of the attributes that ad errors when using CalculateTotals.</summary>
</member>
<member name="P:CARE.Access.JobSchedule.Failed">
 <summary>
 Did this job fail
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.UpgradeTables.ExecuteSQLStatement(CARE.Data.CDBConnection,System.String,System.String@)">
 <summary>Executes the current SQL statement.</summary>
 <param name="pConn">Current <see cref="T:CARE.Data.CDBConnection">CDBConnection</see> object.</param>
 <param name="pSQL">The SQL to be executed.</param>
 <param name="pErrorText">If an error is generated by the SQL, this will be set to the error message.</param>
 <returns>0 if the SQL executes successfully, otherwise 1.</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactSurvey.ValidateDates(CARE.Access.CDBParameters)">
 <summary>
 Validate that SentOn is not after CompletedOn and that both are within Valid From and Valid to. 
 </summary>
 <param name="pParameterList"></param>
 <remarks>Applies to create and update. The rules are the same.</remarks>
</member>
<member name="M:CARE.Access.ContactSurvey.GetRespondedContactCategory(System.String,System.String,CARE.Access.SurveyVersion)">
 <summary>Gets the <see cref="T:CARE.Access.ContactCategory">ContactCategory</see> for the Survey RespondedActivity and RespondedActivityValue.</summary>
 <param name="pActivity">Survey Responded Activity</param>
 <param name="pActivityValue">Survey Responded Activity Value</param>
 <param name="pSurveyVersion">Survey Version being used</param>
 <returns><see cref="T:CARE.Access.ContactCategory">ContactCategory</see> initialised with first matching Category or a pre-initialised class if no category found.</returns>
 <remarks>Used to find the first (newest) Contact Category</remarks>
</member>
<member name="M:CARE.Access.ContactSurveyResponse.ValidateParameters(CARE.Access.CDBParameters)">
 <summary>
 
 </summary>
 <param name="pParameterList"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ContactSurveyResponse.ValidateContactSurveyNumberParameter(CARE.Access.CDBParameters)">
 <summary>
 Validate SurveyNumber for Create Contact Survey
 </summary>
 <param name="pParameterList"></param>
 <remarks>Survey Number must exist to create a contact Survey, but not for update.</remarks>
</member>
<member name="M:CARE.Access.ContactSurveyResponse.ValidateCharAnswerType(System.String,CARE.Access.SurveyAnswer)">
 <summary>
 Char type can only contain A- Z only.
 </summary>
 <param name="pResponse"></param>
 <param name="pSurveyAnswer"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Survey.ValidateParameters(CARE.Access.CDBParameters)">
 <summary>
 Validate Parameters
 </summary>
 <param name="pParameterList"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.Survey.ValidateSurveyNumber(CARE.Access.CDBParameters)">
 <summary>
 Validate the Survey Number if it is present.
 </summary>
 <param name="pParameterList"></param>
 <remarks>Not present when creating.</remarks>
</member>
<member name="M:CARE.Access.SurveyAnswer.ValidateParameters(CARE.Access.CDBParameters)">
 <summary>
 Validate Parameters
 </summary>
 <param name="pParameterList"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.SurveyAnswer.ValidateSurveyAnswerNumber(CARE.Access.CDBParameters)">
 <summary>
 Validate the Survey Number if it is present.
 </summary>
 <param name="pParameterList"></param>
 <remarks>Not present when creating.</remarks>
</member>
<member name="M:CARE.Access.SurveyAnswer.ValidateSurveyQuestionParameter(CARE.Access.CDBParameters)">
 <summary>
 Validate the Survey number
 </summary>
 <param name="pParameterList"></param>
 <remarks>If this Survey Question is to be linked to a Survey there should have enough information in the parameters to Init a Survey</remarks>
</member>
<member name="M:CARE.Access.SurveyAnswer.ValidateSurveyAnswerParameters(CARE.Access.CDBParameters)">
 <summary>
 Validate Parameters for Survey Answers
 </summary>
 <param name="pParameterList"></param>
 <remarks>Validation is the same for Update and Create, so only one validation subroutine.</remarks>
</member>
<member name="M:CARE.Access.SurveyQuestion.ValidateSurveyQuestionNumberParameter(CARE.Access.CDBParameters)">
 <summary>
 
 </summary>
 <param name="pParameterList"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.SurveyQuestion.ValidateSurveyNumberParameter(CARE.Access.CDBParameters)">
 <summary>
 Validate the Survey number
 </summary>
 <param name="pParameterList"></param>
 <remarks>If this Survey Question is to be linked to a Survey there should have enough information  in the parameters to Init a Survey</remarks>
</member>
<member name="M:CARE.Access.SurveyVersion.ValidateSurveyVersionNumberParameter(CARE.Access.CDBParameters)">
 <summary>
 
 </summary>
 <param name="pParameterList"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ActionSet.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.ActionSet,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32)">
 <summary>Create a new set of Actions for each <see cref="T:CARE.Access.Action">Action</see> in the specified Proforma (Template) <see cref="T:CARE.Access.ActionSet">ActionSet</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProFormaSet">The <see cref="T:CARE.Access.ActionSet">ActionSet</see> of Proforma Actions to be used as the basis for the new Actions.</param>
 <param name="pNewActionNumber">The new Action number for the first Action in the set.</param>
 <param name="pRelatedType">The link type for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
</member>
<member name="M:CARE.Access.ActionSet.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.ActionSet,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32)">
 <summary>Create a new set of Actions for each <see cref="T:CARE.Access.Action">Action</see> in the specified Proforma (Template) <see cref="T:CARE.Access.ActionSet">ActionSet</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProFormaSet">The <see cref="T:CARE.Access.ActionSet">ActionSet</see> of Proforma Actions to be used as the basis for the new Actions.</param>
 <param name="pNewActionNumber">The new Action number for the first Action in the set.</param>
 <param name="pRelatedType">The type of object for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
 <param name="pActionerType">The type of object for an Actioner link to be created for each Action.</param>
 <param name="pActionerNumber">The number of the Actioner to be created for each Action.</param>
</member>
<member name="M:CARE.Access.ActionSet.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.ActionSet,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,System.Int32,System.Int32)">
 <summary>Create a new set of Actions for each <see cref="T:CARE.Access.Action">Action</see> in the specified Proforma (Template) <see cref="T:CARE.Access.ActionSet">ActionSet</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProFormaSet">The <see cref="T:CARE.Access.ActionSet">ActionSet</see> of Proforma Actions to be used as the basis for the new Actions.</param>
 <param name="pNewActionNumber">The new Action number for the first Action in the set.</param>
 <param name="pRelatedType">The type of object for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
 <param name="pActionerType">The type of object for an Actioner link to be created for each Action.</param>
 <param name="pActionerNumber">The number of the Actioner to be created for each Action.</param>
 <param name="pRelatedDocument">The number of a Document to be linked to each Action.</param>
 <param name="pRelatedExamCentreId">The number of an Exam Centre to be linked to each Action.</param>
</member>
<member name="M:CARE.Access.ActionSet.CreateFromProForma(CARE.Access.CDBEnvironment,CARE.Access.ActionSet,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,CARE.IActionLink.ActionLinkObjectTypes,System.Int32,System.Int32,System.Int32,System.DateTime,System.DateTime,System.Boolean)">
 <summary>Create a new set of Actions for each <see cref="T:CARE.Access.Action">Action</see> in the specified Proforma (Template) <see cref="T:CARE.Access.ActionSet">ActionSet</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProFormaSet">The <see cref="T:CARE.Access.ActionSet">ActionSet</see> of Proforma Actions to be used as the basis for the new Actions.</param>
 <param name="pNewActionNumber">The new Action number for the first Action in the set.</param>
 <param name="pRelatedType">The type of object for a related link to be created for each Action.</param>
 <param name="pRelatedNumber">The link number for a related link to be created for each Action.</param>
 <param name="pActionerType">The type of object for an Actioner link to be created for each Action.</param>
 <param name="pActionerNumber">The number of the Actioner to be created for each Action.</param>
 <param name="pRelatedDocument">The number of a Document to be linked to each Action.</param>
 <param name="pRelatedExamCentreId">The number of an Exam Centre to be linked to each Action.</param>
 <param name="pStartProcessingDate">The base date to use for calculating the new Action dates when the Proforma Action uses negative offsets or is the main (first) Action in the set.</param>
 <param name="pEndProcessingDate">The base date to use for calculating the new Action dates when the Proforma Action does not use negative offsets.</param>
 <param name="pCreateActions">True to save the new Actions and related data in the database, otherwise False to set the Action data without saving.</param>
</member>
<member name="M:CARE.Access.ActionSet.UpdateFromProforma(CARE.Access.CDBEnvironment,CARE.Access.ActionSet,CARE.Data.CDBFields,CARE.Data.AnsiJoin,System.DateTime,System.DateTime)">
 <summary>Create or update the set of Actions for each <see cref="T:CARE.Access.Action">Action</see> in the specified Proforma (Template) <see cref="T:CARE.Access.ActionSet">ActionSet</see>.</summary>
 <param name="pEnv"></param>
 <param name="pProFormaSet">The <see cref="T:CARE.Access.ActionSet">ActionSet</see> of Proforma Actions to be used as the basis for the new Actions.</param>
 <param name="pWhereClause">A <see cref="T:CARE.Data.CDBFields">CDBFields Collection</see> containing the where clause to find existing records.</param>
 <param name="pLinkTableJoin">An <see cref="T:CARE.Data.AnsiJoin">AnsiJoin</see> record containing a join from the actions table to he link table.</param>
 <param name="pStartProcessingDate">The base date to use for calculating the new Action dates when the Proforma Action uses negative offsets or is the main (first) Action in the set.</param>
 <param name="pEndProcessingDate">The base date to use for calculating the new Action dates when the Proforma Action does not use negative offsets.</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.ActionSet.CreateActionsFromProvisional(CARE.Access.CDBEnvironment,CARE.Collections.CollectionList{CARE.Access.Action},System.Int32)">
 <summary>Create <see cref="T:CARE.Access.Action">Actions</see> from Proforma (Template) when those Action objects have already been set up.</summary>
 <param name="pEnv"></param>
 <param name="pActionsColl">A collection containing the Actions to be created that are from this ActionSet.</param>
 <param name="pWorkstreamId">The number of the Workstream to be linked to each Action.</param>
</member>
<member name="M:CARE.Access.ContactAccount.HasIbanBankChanged(System.String)">
 <summary>Has the bank portion of the IBAN Number changed?</summary>
</member>
<member name="M:CARE.Access.CreditCardAuthorisation.SendTransactionRequest(CARE.Access.ICardAuthorisationService,System.String,CARE.Access.CardSale)">
 <summary>
 Sends the transaction request to TNS and set the CCA fields with response data
 </summary>
 <param name="pTns">Authorisation Service interface</param>
 <param name="pRequestData">Request string with all the transactiondetails</param>
 <param name="pCS">Card Sales</param>
 <remarks>Connection error will be stored as ''</remarks>
</member>
<member name="M:CARE.Access.DirectDebit.ValidateReference(System.String)">
 <summary>Validate the Direct Debit Reference to ensure it is not being used by another live Direct Debit.</summary>
</member>
<member name="P:CARE.Access.DirectDebit.DateSigned">
 <summary>Gets the date the Direct Debit mandate was signed.</summary>
</member>
<member name="P:CARE.Access.DirectDebit.BankDetailsChanged">
 <summary>Gets a boolean flag indicating whether the bank details have changed (within the same Bank) since the last Direct Debit claim.</summary>
 <remarks>Used in combination with <see cref="P:CARE.Access.DirectDebit.PreviousBankDetailsNumber">PreviousBankDetailsNumber</see>.</remarks>
</member>
<member name="P:CARE.Access.DirectDebit.PreviousBankDetailsNumber">
 <summary>Gets the bank details number of the previous bank account when the bank details have changed (within the same bank) since the last Direct Debit claim.</summary>
 <remarks>Used in combination with <see cref="P:CARE.Access.DirectDebit.BankDetailsChanged">BankDetailsChanged</see>.</remarks>
</member>
<member name="M:CARE.Access.DirectDebit.ChangePayer(CARE.Access.Contact)">
 <summary>Change the payer contact and address of this Direct Debit.</summary>
 <param name="pNewPayer"><see cref="T:CARE.Access.Contact">Contact</see> that will become the new payer.  Muast have been initialised to the required contact and address numbers.</param>
 <remarks>This will only change the payer contact and address numbers, it will NOT change the bank details.</remarks>
</member>
<member name="M:CARE.Access.EventDelegate.SetDelegateActivitiesAndLinks">
 <summary>Populate Activities and Links collections with data for this Delegate.</summary>
</member>
<member name="P:CARE.Access.EventDelegate.Links">
 <summary>Gets a <see cref="T:CARE.Collections.CollectionList`1">CollectionList</see>  of Delegate Links for this Delegate.</summary>
 <returns><see cref="T:CARE.Collections.CollectionList`1">CollectionList</see>  of Delegate Links</returns>
</member>
<member name="M:CARE.Access.FinancialHistory.IsConfirmedTransaction">
 <summary>Is this transaction a confirmation of a provisional batch?</summary>
</member>
<member name="M:CARE.Access.FinancialHistory.IsEventBookingTransaction">
 <summary>Is this a transaction created as a result of amending an Event Booking?</summary>
 <returns>True if the transaction was created by amending an Event Booking, otherwise False.</returns>
</member>
<member name="M:CARE.Access.FinancialHistory.UpdateInvoiceForMove(System.Int32,System.Int32,System.Boolean,System.Boolean)">
 <summary>When changing the payer (moving) of a transaction that had invoice allocations, update the paid <see cref="T:CARE.Access.Invoice">Invoice</see> and <see cref="T:CARE.Access.CreditCustomer">CreditCustomer</see>.</summary>
 <param name="pOrigBatchNumber">Batch number of the original transaction</param>
 <param name="pOrigTransNumber">Transaction number of the original transaction</param>
 <param name="pPositiveLinesOnly">Include positive lines only?</param>
 <param name="pReverseData">Roll back the changes due to a failure of the move?</param>
</member>
<member name="P:CARE.Access.FinancialHistory.IsFinancialAdjustment">
 <summary>Is this transaction the result of a financial adjustment?</summary>
 <returns>True if the transaction is the result of a financial adjustment, otherwise False</returns>
</member>
<member name="M:CARE.Access.FinancialHistory.CanReverseAdjustedTransaction(CARE.Access.FinancialHistory.SalesLedgerItems)">
 <summary>Can a financial adjustment transaction be further adjusted?</summary>
 <param name="pSLItems">The Sales Ledger items (if any) it contains.</param>
 <returns>True if the transaction can be adjusted, otherwise False.</returns>
</member>
<member name="M:CARE.Access.FinancialHistory.ContainsSalesLedgerItems(CARE.Access.CDBEnvironment,System.Int32,System.Int32)">
 <summary>Does the transaction contain sales ledger items?</summary>
 <param name="pEnv"></param>
 <param name="pBatchNumber">The batch number to check.</param>
 <param name="pTransactionNumber">The transaction number to check.</param>
 <returns><see cref="T:CARE.Access.FinancialHistory.SalesLedgerItems">ContainsSLItems</see> enumeration detailing the type of Sales Ledger items present</returns>
 <remarks>The Sales Ledger items checked are: 'N' Invoice payments, 'U' Unallocated Sales Ledger Cash, 'L' Sales Ledger Cash Allocations and 'K' Credit Note Allocations.</remarks>
</member>
<member name="M:CARE.Access.FinancialHistory.ContainsSalesLedgerItems(CARE.Access.CDBEnvironment,System.Int32,System.Int32,System.Int32)">
 <summary>Does the transaction contain sales ledger items?</summary>
 <param name="pEnv"></param>
 <param name="pBatchNumber">The batch number to check.</param>
 <param name="pTransactionNumber">The transaction number to check.</param>
 <param name="pLineNumber">The line number to check when checks are required at line level.</param>
 <returns><see cref="T:CARE.Access.FinancialHistory.SalesLedgerItems">ContainsSLItems</see> enumeration detailing the type of Sales Ledger items present</returns>
 <remarks>The Sales Ledger items checked are: 'N' Invoice payments, 'U' Unallocated Sales Ledger Cash, 'L' Sales Ledger Cash Allocations and 'K' Credit Note Allocations.</remarks>
</member>
<member name="M:CARE.Access.FinancialHistory.CanPrintReceipt">
 <summary>Can a Receipt be printed for this transaction?</summary>
</member>
<member name="M:CARE.Access.FinancialHistory.ReverseInvoiceCashAllocation(System.Int32,System.String,System.Double,CARE.Access.BatchTransactionAnalysis,System.DateTime,System.String)">
 <summary>When reversing or re-analysing an un-allocated sales ledger cash line find and reverse any invoice payment history.</summary>
 <param name="pOriginalLineNumber">Line number of the original analysis line.</param>
 <param name="pOriginalLineType">Line type of the original analysis line.</param>
 <param name="pOriginalAmount">Amount of the original analysis line.</param>
 <param name="pNewBTA">BatchTransactionAnalysis for the new line.</param>
 <param name="pTransactionDate">Date of the adjustment transaction.</param>
 <param name="pAdjustmentStatus">The adjustment status.</param>
</member>
<member name="M:CARE.Access.GiftAidDeclaration.GetPreviousDeclarationWhere(System.Boolean)">
 <summary>
 Generates a where clause for getting the previous declaration.  In future, please just use this function to get the previous GAD.
 </summary>
 <returns></returns>
 <remarks>The intention is that if there is one central place that decided what a previous GAD is, then we can consitently use it rather than copy the same code everywhere</remarks>
</member>
<member name="M:CARE.Access.GiftAidDeclaration.ProcessChangeOfEndDate">
 <summary>If the End Date has changed, then find any claimed payments that have now become invalidated and create adjustment transactions.
 The End Date will have already been changed.</summary>
</member>
<member name="M:CARE.Access.GiftAidDeclaration.ProcessChangeOfStartDate">
 <summary>If the Start Date has changed, then find any unclaimed adjustment payments that have now become invalidated and create adjustment transactions.
 The Start Date will have already been changed.</summary>
</member>
<member name="M:CARE.Access.GiftAidDeclaration.DeleteUnclaimedAdjustments(System.Boolean)">
 <summary>If the GAD is being deleted or the dates have changed then need to delete any unclaimed adjustment transactions.
 These will have been created if the GAD start over-lapped with the adjustments created for a previous GAD.</summary>
 <param name="pDeleteDeclaration">The entire GAD is being deleted.</param>
</member>
<member name="P:CARE.Access.Member.CMTDate">
 <summary>Following a change of membership type (CMT), this is the date the new membership is effective from.</summary>
</member>
<member name="M:CARE.Access.Member.AddTerm(CARE.Access.MembershipType,System.String,System.Int32)">
 <summary>
 
 </summary>
 <param name="pMemberShipType"></param>
 <param name="pOldDate">The date that we want ot move on.</param>
 <param name="pTermDuration">Number of Months or Years dependent on the value of pMemebershipType.PaymentTerm.</param>
 <returns></returns>
 <remarks>Suitably bland name as this function is intended to to be used for CardExpiryDate and RenewalDate</remarks>
</member>
<member name="M:CARE.Access.Member.ResetNumberOfMembers(System.Int32)">
 <summary>Reset the NumberOfMembers to the specified value.</summary>
 <param name="pNumberOfMembers">The total number of members for the membership type in this membership</param>
 <remarks>The NumberOfMembers is only updated when the MembershipType.SetNumberOfMembers = True and the MembershipType.MembersPerOrder is greater than zero.</remarks>
</member>
<member name="M:CARE.Access.Member.GetEarliestCMTDate(System.DateTime)">
 <summary>Get the earliest date that can be set for a CMT.</summary>
 <param name="pTermStartDate">The start date of the current renewal period.</param>
</member>
<member name="M:CARE.Access.MergeData.CheckDuplicateExamUnitRecords(CARE.Access.CDBEnvironment@,System.Int32,System.Int32)">
 <summary>
 This method finds out, if there are any duplicate exam_units between main contact and duplicate contact. If yes then we cannot merge the record
 </summary>
 <param name="pEnv">Current environment class</param>
 <param name="pMainContact">Main conta</param>
 <param name="pDuplicateContact"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.OrderPaymentSchedule.OrderPaymentHistory">
 <summary>
 The OrderPaymentHistories of this scheduled payment, empty of no payments made
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.OrderPaymentSchedule.IsUpdateFromProvisional">
 <summary>Has a provisional record been updated to be non-provisional?</summary>
</member>
<member name="M:CARE.Access.OrderPaymentSchedule.GetOrderPaymentHistory">
 <summary>
 Gets the OrderPaymentHistory for this OrderPaymentSchedule
 </summary>
 <returns>A List of OrderPaymentHistory objects or an empty List of OrderPaymentHistory objects</returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.PaymentFrequency.IsOffsetMonthsValid(System.String,System.Int32,System.Int32,System.Int32,System.Int32@)">
 <summary>Validate the OffsetMonths value.</summary>
 <param name="pPeriod">PaymentFrequency Period ((D)ays or (M)onths</param>
 <param name="pFrequency">PaymentFrequency Frequency</param>
 <param name="pInterval">PaymentFrequency Interval</param>
 <param name="pOffsetMonths">PaymentFrequency Offset</param>
 <param name="pMaxOffset">Maximum Offset Months value which will be set and returned</param>
 <returns>True if valid, otherwise False</returns>
</member>
<member name="M:CARE.Access.PaymentFrequency.GetCalculatedOffsetMonths">
 <summary>Get the offset months as they will be applied to this specific usage.</summary>
 <returns>The calculated offset months as it will be applied.</returns>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.#ctor">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.PaymentPlanDetail" /> class.
 </summary>
 <remarks>This constructor constructs a payment detail line without reference to the containing payment plan.  This 
 makes it difficult for the payment detail line to know how to behave.  This contstructor will continue to work and
 the payment plan will be instantiated from the database if required, but code should construct the class passing the
 payment plan where possible.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.#ctor(CARE.Access.PaymentPlan)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Access.PaymentPlanDetail" /> class.
 </summary>
 <param name="pPaymentPlan">The containing payment plan.</param>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Amount">
 <summary>Fixed Amount including VAT (i.e. Gross)</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True this will return the actual price of this detail line,
  otherwise it is either the current or future price depending on the date of the price change.
   The price returned takes into account the <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see>.
   The calculated price will include any required VAT amount.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime,System.Double)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <param name="pOverrideQuantity">The quantity of items being priced</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True this will return the actual price of this detail line,
  otherwise it is either the current or future price depending on the date of the price change.
   The price returned takes into account the <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see> (or the <paramref name="pOverrideQuantity">override quantity</paramref> if not zero).
   The calculated price will include any required VAT amount.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime,CARE.Access.VatRate)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <param name="pVatRate">The VAT rate to use in the pricing</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True this will return the actual price of this detail line,
  otherwise it is either the current or future price depending on the date of the price change.
   The price returned takes into account the <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see>.
   The calculated price will include any required VAT amount using the <paramref name="pVATRate">VAT rate supplied</paramref>.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime,CARE.Access.VatRate,System.Double)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <param name="pOverrideQuantity">The quantity of items being priced</param>
 <param name="pVatRate">The VAT rate to use in the pricing</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True this will return the actual price of this detail line,
  otherwise it is either the current or future price depending on the date of the price change.
   The price returned takes into account the <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see>
  (or the <paramref name="pOverrideQuantity">override quantity</paramref> if not zero).
   The calculated price will include any required VAT amount using the <paramref name="pVATRate">VAT rate supplied</paramref>.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime,CARE.Access.VatRate,System.Double,System.Boolean)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <param name="pOverrideQuantity">The quantity of items being priced</param>
 <param name="pVatRate">The VAT rate to use in the pricing</param>
 <param name="pRenewals">Boolean flag indicating whether this is a Renewals process in which the price must be re-calculated</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True and <paramref name="pRenewals">it is not a renewal</paramref>
 this will return the actual price of this detail line,  otherwise it is either the current or future
 price depending on the date of the price change.   The price returned takes into account the 
 <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see> (or the <paramref name="pOverrideQuantity">override quantity</paramref> if not zero).
  The calculated price will include any required VAT amount using the <paramref name="pVATRate">VAT rate supplied</paramref>.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime,CARE.Access.VatRate,System.Double,System.Boolean,System.Boolean)">
 <summary>The price for this payment plan detail line</summary>
 <param name="pDate">Date the price is required for</param>
 <param name="pOverrideQuantity">The quantity of items being priced</param>
 <param name="pVatRate">The VAT rate to use in the pricing</param>
 <param name="pRenewals">Boolean flag indicating whether this is a Renewals process in which the price must be re-calculated</param>
 <param name="pCalcRenewalAmountOnly">Boolean flag indicating whether the price is for a Renewal Amount calculation in which the full annual amount is required</param>
 <returns>Calculated Price including VAT</returns>
 <remarks>If <see cref="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">HasPriceInfo</see> is True and <paramref name="pRenewals">it is not a renewal</paramref>
 this will return the actual price of this detail line,  otherwise it is either the current or future
 price depending on the date of the price change.   The price returned takes into account the 
 <see cref="P:CARE.Access.PaymentPlanDetail.Quantity">Quantity</see> (or the <paramref name="pOverrideQuantity">override quantity</paramref> if not zero).
  The calculated price will include any required VAT amount using the <paramref name="pVATRate">VAT rate supplied</paramref>.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.PaymentPlan">
 <summary>
 The containing payment plan for this detail line.
 </summary>
 <remarks>If the payment plan is pecified when the detail line is instantiated, this will be that payment plan. If not,
 the payment plan will be constructed from the database using the order number. Once a payment plan has been constructed,
 it will not be constructed again for the lifetime of the detail line.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.OrderNumber">
 <summary>
 The order number associated with the containing payment plan.
 </summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.ProratedPrice(System.DateTime,System.DateTime)">
 <summary>
 Gets the prorated price.
 </summary>
 <param name="pStartDate">The start date of the proration period</param>
 <param name="pEndDate">The end date of the proration period</param>
 <returns>The prorated price for the protion of the term indicated</returns>
 <remarks>The calculation is performed by taking the currently indicated price for the line item at the term start and
 multiplying it by the proportion of months in the full term represented by the number of months between the 
 <paramref name="pStartDate">start</paramref> and <paramref name="pEndDate">end</paramref> dates.  In practice,
 multiplication is performed before division to ensure maximum accuracy.  The calcultion uses the <see cref="P:CARE.Access.PaymentPlanDetail.Price(System.DateTime)">Price</see>
 property and <see cref="M:CARE.Utilities.Common.MonthsDifference(System.DateTime,System.DateTime)">MonthsDifference</see> function in calculating the result.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.ProratedPrice(System.Int32,System.Int32)">
 <summary>Gets the prorated price.</summary>
 <param name="pFullTermMonths">The current number of months covered by the <see cref="M:CARE.Access.PaymentPlanDetail.FullPrice(System.DateTime,System.String)">FullPrice</see>.</param>
 <param name="pNumberOfMonths">The number of months the <see cref="M:CARE.Access.PaymentPlanDetail.FullPrice(System.DateTime,System.String)">FullPrice</see> is to be prorated.</param>
 <returns>Prorated Price</returns>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.CalculateVATAmount(System.Double)">
 <summary>Calculate the VATAmount for the current Balance for the MailMege file.</summary>
 <param name="pVATPercentage">VAT percentage to use</param>
 <returns>VAT Amount appropriate for the current Balance</returns>
 <remarks>This is only used by PaymentPlan.WriteMailMergeOutput</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.NetFixedAmount">
 <summary>Fixed Amount excluding VAT</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.AccruesInterest">
 <summary>Gets a boolean flag indicating whether the Product accrues interest.</summary>
 <returns>True if the Product accrues interest, otherwise False.</returns>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.LoanInterest">
 <summary>Gets a boolean flag identifying the ProductRate is for Loan Interest.</summary>
 <returns>True if the ProductRate is for Loan Interest, otherwise False.</returns>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.ModifierPrice">
 <summary>The price of the detail calculated from the Rate Modifiers.  If the <see cref="P:CARE.Access.PaymentPlanDetail.ModifierPerItem" /> flag is set to 'Y' then this is the price per item.</summary>
 <remarks>This is not set if multiple Rate Modifiers were used.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.ModifierPerItem">
 <summary>Flay indicating whether the <see cref="P:CARE.Access.PaymentPlanDetail.ModifierPrice" /> is the total price or the price for a single <see cref="P:CARE.Access.PaymentPlanDetail.ModifierActivityQuantity" />.</summary>
 <remarks>This will be set to M if multiple Rate Modifiers were used.</remarks>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.UnitPrice">
 <summary>The full price of this detail line for a single item before any discounts or pro-rating etc. have been applied.</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.NetAmount">
 <summary>The net price of this detail line taking into account the quantity.  This is after discounts, pro-rating etc. have been applied.</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.VatAmount">
 <summary>The VAT amount of this detail line taking into account the quantity and using the payer VAT category.  This is after discounts, pro-rating etc. have been applied.</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.GrossAmount">
 <summary>The gross price of this detail line taking into account the quantity.  This is after discounts, pro-rating etc. have been applied.</summary>
</member>
<member name="P:CARE.Access.PaymentPlanDetail.HasPriceInfo">
 <summary>Does the PaymentPlanDetail contain the Price information</summary>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.SetCMTOldTypeBalance(System.Boolean,System.Double@)">
 <summary>Set the new Balance on a <see cref="T:CARE.Access.PaymentPlanDetail">Detail</see> line when this Detail line is for the old membership type.</summary>
 <param name="pAdvancedCMT">Is Advanced CMT being used?</param>
 <param name="pOutstandingRemainingBalance">Sum outstanding Balances.</param>
 <remarks>For an Advanced CMT, new Balances are calculated according to the <see cref="P:CARE.Access.PaymentPlanDetail.CMTProrateLineType">CMT Prorate Line Type</see>.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.SetCMTNewTypeProrateBalance(System.Boolean,System.Double,System.Int32)">
 <summary>Set the new Balance on a <see cref="T:CARE.Access.PaymentPlanDetail">Detail</see> line when this Detail line is for the new membership type.</summary>
 <param name="pAdvancedCMT">Is Advanced CMT being used?</param>
 <param name="pNewBalanceTotal">Sum balance of the new Detail lines</param>
 <param name="pMonthsRemaining">The number of months remaining for the new membership type.</param>
 <remarks>For an Advanced CMT, new Balances are calculated according to the <see cref="P:CARE.Access.PaymentPlanDetail.CMTProrateLineType">CMT Prorate Line Type</see>.</remarks>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.SetCMTLineNoRenewalRequired(System.String)">
 <summary>Set <see cref="P:CARE.Access.PaymentPlanDetail.ValidTo">Valid To</see> date to the renewal date and <see cref="P:CARE.Access.PaymentPlanDetail.UnitPrice">Unit Price</see> to zero so that this line does not get renewed.</summary>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.AllocateCMTExcessPayment(System.Double)">
 <summary>Set the excess payment amount to the amount not allocated for late refunding etc.</summary>
 <param name="pNewExcessPayment">Amount of excess payment not allocated</param>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.SetCMTOtherLinePartYearPrice">
 <summary>Used by CMT to re-set prices to pro-rated figures when dealing with Detail line added part way through year.</summary>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.SetCMTOldMembershipProratedPrice(System.Double)">
 <summary>Used by CMT to re-set prorted figures to account for rounding when advanced CMT is not being used.</summary>
</member>
<member name="M:CARE.Access.PaymentPlanDetail.CMTUpdatePreviousPriceData">
 <summary>Used by CMT to ensure that the pricing data is correct when fixed amount is set.</summary>
 <remarks>Earlier versions of the software sometimes incorrectly set the UnitPrice as zero when the ProductRate had a price of zero, 
 when it should have been set to the FixedAmount.  This will correct the UnitPrice so that the CMT pro-rating calculations can be performed.</remarks>
</member>
<member name="M:CARE.Access.PurchaseInvoiceDetail.Cancel(System.String,System.String,System.String,System.String,System.String)">
 <summary>Cancel the Purchase Invoice Detail.</summary>
 <param name="pCancelReason">Reason for the cancellation.</param>
 <param name="pCancelBy">User performing the cancellation.</param>
 <param name="pCancelOn">Date cancellation takes place.</param>
 <param name="pCancelSource">The source of the cancellation.</param>
 <param name="pAdjustmentStatus">The adjustment status that should be applied.</param>
</member>
<member name="M:CARE.Access.RegisteredUser.LogOn(System.String,System.Boolean)">
 <summary>
 Checks if the registered user's password matches the one passed in and that the user is not locked out
 </summary>
 <param name="pPassword"></param>
 <returns>True - if the passwords match and the user is not locked out</returns>
 <remarks></remarks>
</member>
<member name="P:CARE.Access.RegisteredUser.IsLockedOut">
 <summary>
 Returns 'True' if the configured number of minutes has not elapsed after the user has exhausted the maximum login attempts
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.TraderAnalysisLines.InitAnalysisFromBTForMove(CARE.Collections.CollectionList{CARE.Access.BatchTransactionAnalysis},CARE.Access.Batch.BatchTypes,System.Int32,System.Int32,System.String,System.String,CARE.Access.CDBCollection,System.Boolean)">
 <summary>Initialise collection of <see cref="T:CARE.Access.TraderAnalysisLine">TraderAnalysisLine</see> items from a collection of <see cref="T:CARE.Access.BatchTransactionAnalysis">BatchTransactionAnalysis</see> items for a Financial Adjustment Move.</summary>
 <param name="pAnalysis"><see cref="T:CARE.Collections.CollectionList`1">CollectionList</see> of BatchTransactionAnalysis objects.</param>
 <param name="pBatchType">Current batch type</param>
 <param name="pPayerContactNumber">Contact number of the payer</param>
 <param name="pPayerAddressNumber">Address number of the payer</param>
 <param name="pBatchCurrencyCode">Batch currency code used to determine whether to use the amount or currency amount</param>
 <param name="pTransDate">Date of the transaction</param>
 <param name="pStockMovements"><see cref="T:CARE.Access.CDBCollection">CDBCollection</see> of <see cref="T:CARE.Access.StockMovement"> StockMovement's</see></param>
 <param name="pPositiveTransOnly">True if the Move is for an adjusted transaction that contained sales ledger payments</param>
</member>
<member name="M:CARE.Access.TraderAnalysisLines.InitAnalysisFromBT(CARE.Collections.CollectionList{CARE.Access.BatchTransactionAnalysis},CARE.Access.Batch.BatchTypes,CARE.Access.Batch.AdjustmentTypes,System.String,System.Int32,System.Int32,System.String,System.String,CARE.Access.CDBCollection,System.Boolean)">
 <summary>Initialise collection of <see cref="T:CARE.Access.TraderAnalysisLine">TraderAnalysisLine</see> items from a collection of <see cref="T:CARE.Access.BatchTransactionAnalysis">BatchTransactionAnalysis</see> items.</summary>
 <param name="pAnalysis"><see cref="T:CARE.Collections.CollectionList`1">CollectionList</see> of BatchTransactionAnalysis objects.</param>
 <param name="pBatchType">Current batch type</param>
 <param name="pFinancialAdjustment">Financial adjustment type</param>
 <param name="pSundryCreditProductCode">Sundry credit product code used to set the <see cref="T:CARE.Access.TraderAnalysisLine">TraderAnalysisLine</see> line type to be a sundry credit note</param>
 <param name="pPayerContactNumber">Contact number of the payer</param>
 <param name="pPayerAddressNumber">Address number of the payer</param>
 <param name="pBatchCurrencyCode">Batch currency code used to determine whether to use the amount or currency amount</param>
 <param name="pTransDate">Date of the transaction</param>
 <param name="pStockMovements"><see cref="T:CARE.Access.CDBCollection">CDBCollection</see> of <see cref="T:CARE.Access.StockMovement"> StockMovement's</see></param>
 <param name="pSundryCreditApplication">Is this from a sundry credit application</param>
</member>
<member name="M:CARE.Access.TraderAnalysisLines.InitAnalysisFromBT(CARE.Collections.CollectionList{CARE.Access.BatchTransactionAnalysis},CARE.Access.Batch.BatchTypes,CARE.Access.Batch.AdjustmentTypes,System.String,System.Int32,System.Int32,System.String,System.String,CARE.Access.CDBCollection,System.Boolean,System.Boolean)">
 <summary>Initialise collection of <see cref="T:CARE.Access.TraderAnalysisLine">TraderAnalysisLine</see> items from a collection of <see cref="T:CARE.Access.BatchTransactionAnalysis">BatchTransactionAnalysis</see> items.</summary>
 <param name="pAnalysis"><see cref="T:CARE.Collections.CollectionList`1">CollectionList</see> of BatchTransactionAnalysis objects.</param>
 <param name="pBatchType">Current batch type</param>
 <param name="pFinancialAdjustment">Financial adjustment type</param>
 <param name="pSundryCreditProductCode">Sundry credit product code used to set the <see cref="T:CARE.Access.TraderAnalysisLine">TraderAnalysisLine</see> line type to be a sundry credit note</param>
 <param name="pPayerContactNumber">Contact number of the payer</param>
 <param name="pPayerAddressNumber">Address number of the payer</param>
 <param name="pBatchCurrencyCode">Batch currency code used to determine whether to use the amount or currency amount</param>
 <param name="pTransDate">Date of the transaction</param>
 <param name="pStockMovements"><see cref="T:CARE.Access.CDBCollection">CDBCollection</see> of <see cref="T:CARE.Access.StockMovement"> StockMovement's</see></param>
 <param name="pSundryCreditApplication">Is this from a sundry credit application</param>
 <param name="pMovePositiveTransOnly">For AdjustmentType of atMove will only include positive analysis lines</param>
</member>
<member name="M:CARE.Access.TraderApplication.ProduceInvoice(CARE.Access.CDBParameters,CARE.Access.CDBParameters@)">
 <summary>Prints Invoices</summary>
 <param name="pParams">Parameters collection from Trader</param>
 <param name="pResults">Parameters collection of results to return to Trader</param>
 <returns>Count of the number of Invoices printed</returns>
</member>
<member name="M:CARE.Access.TraderApplication.GetBatchInvoices(CARE.Access.CDBParameters@)">
 <summary>Select Invoices for display on tpBatchInvoiceSummary Trader page</summary>
 <param name="pParams">Parameters collection from Trader</param>
 <returns>CDBParameters Collection of all Invoices selected</returns>
</member>
<member name="M:CARE.Access.TraderApplication.GetInvoicesWhereClause(CARE.Data.CDBFields@,CARE.Data.AnsiJoins@,CARE.Access.CDBParameters,System.Boolean,System.Boolean,System.Boolean)">
 <summary>Build Where clause for Invoice printing</summary>
 <param name="pWhereFields">WhereFields collection to be build</param>
 <param name="pAnsiJoins">AnsiJoins to be added</param>
 <param name="pParams">Parameters collection from Trader</param>
 <param name="pPartPaidOnly">Only include part-paid Invoices</param>
 <param name="pBatchOwnership">Only include owned invoices</param>
 <param name="pUseTransDate">Use transaction date etc. in SQL</param>
</member>
<member name="M:CARE.Access.TraderApplication.GetInvoicesEvents(CARE.Data.AnsiJoins@,CARE.Access.CDBParameters,System.Boolean,System.Boolean,System.Boolean)">
 <summary>Add Events selection to Invoice printing SQL</summary>
 <param name="pAnsiJoins">AnsiJoins collection to be added to</param>
 <param name="pParams">Parameters collection from Trader</param>
 <param name="pPartPaidOnly">Only include part-paid Invoices</param>
 <param name="pBatchOwnership">Only include owned invoices</param>
 <param name="pUseTransDate">Include transaction date etc. in SQL</param>
</member>
<member name="M:CARE.Access.TraderApplication.SelectInvoicesForPrinting(CARE.Access.CDBParameters,System.Boolean,System.Boolean,System.Boolean)">
 <summary>Select Invoices for printing and further processing.</summary>
 <param name="pParams">Parameter collection from Trader</param>
 <param name="pUseTransDate">Date range has been entered and configuration option invoice_date_from_event_start is set</param>
 <param name="pBatchOwnership">Configuration option opt_batch_ownershipis set and configuration option opt_batch_per_user = "DEPARTMENT"</param>
 <param name="pPartPaidOnly">Only include Invoices that have received a payment</param>
 <returns>SQLStatement</returns>
</member>
<member name="M:CARE.Access.TraderApplication.SelectInvoicesForPrinting(CARE.Access.CDBParameters,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
 <summary>Select Invoices for printing and further processing.</summary>
 <param name="pParams">Parameter collection from Trader</param>
 <param name="pUseTransDate">Date range has been entered and configuration option invoice_date_from_event_start is set</param>
 <param name="pBatchOwnership">Configuration option opt_batch_ownershipis set and configuration option opt_batch_per_user = "DEPARTMENT"</param>
 <param name="pPartPaidOnly">Only include Invoices that have received a payment</param>
 <param name="pCountOnly">Build SQL for a Count</param>
 <returns>SQLStatement</returns>
</member>
<member name="M:CARE.Access.TraderApplication.ClearSelectedInvoiceNumbers(System.Int32,System.String)">
 <summary>After print-preview of Invoices remove any Invoice numbers that got added</summary>
 <param name="pPrintJobNumber">Print Job Number of the Invoice run</param>
 <param name="pInvoiceNumbers">A Comma-separated list of invoice numbers to be removed</param>
</member>
<member name="M:CARE.Access.TraderApplication.IsOriginalAnalsysisLine(CARE.Access.BatchTransaction,CARE.Access.TraderAnalysisLine,CARE.Access.CDBParameters)">
 <summary>Used when cancelling out of a financial adjustment Trader to work out whether the Salesledger UnallocatedCash line is the original BTA line.</summary>
</member>
<member name="P:CARE.Access.TraderTransaction.OriginalOPS">
 <summary>
 BR19606 For Transaction History, Analysis followed by Edit or Delete will change the Order Payment Schedule, when Edit or Delete are clicked. This is the original order payment history before the change.
 If the user cancels analysis we need the original (before analyis changed the OPS) OPS to restore the database to a stable conditon. The OPS needs to be to Smart Client so that cancel can use it. 
 </summary>
 <value>The order payment schedule before any changes, or Nothing</value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.DataFinder.ProductsOnCompanyControlsSQL(CARE.Access.CDBEnvironment)">
 <summary>
 Wrapper for ProductsOnCompanyControlsSQL() to allow it to be used standalone, all it needs is a connection, the rest is self contained.
 </summary>
 <param name="pEnv"></param>
 <returns></returns>
 <remarks>Required because DataFinder does not have a constructor than initialises mvEnv</remarks>
</member>
<member name="M:CARE.Access.DataFinder.ProductsOnCompanyControlsSQL">
 <summary>
 SQL to find all the DISTINCT products on table company_controls
 </summary>
 <returns>A string containing SQL to find all the DISTINCT products on table company_controls</returns>
 <remarks>Uses maintenance _attributes to determine the product columns, intended for use in a NOT IN clause when interrogating the product table.</remarks>
</member>
<member name="M:CARE.Access.DataFinder.AddBankDetailsClause(System.String@)">
 <summary>
 Add bank details to the where clause
 </summary>
 <param name="pWhere">Where clause string by ref</param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.WebPageUserControl.CreateWebPage(System.String,CARE.Access.CDBEnvironment,System.Int32)">
 <summary>
 Creates web page required for TNS
 </summary>
 <param name="pPageName">Page Name </param>
 <param name="pEnv">Environment</param>
 <param name="pPageNumber">Page Number</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.WebPageUserControl.CreateWebPageItem(CARE.Access.WebPage,CARE.Access.CDBEnvironment,System.Boolean)">
 <summary>
 Creates web page item entry required to setup default TNS page
 </summary>
 <param name="pWP"></param>
 <param name="pEnv"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.WebPageUserControl.CreateWebPageItem(CARE.Access.WebPage,CARE.Access.CDBEnvironment,System.Boolean,System.Int32)">
 <summary>
 Creates web page item entry required to setup default TNS page
 </summary>
 <param name="pWP">Web Page object</param>
 <param name="pEnv">environment</param>
 <param name="pProcessPayment">flag to check of this is called to create process payment page or display content page</param>
 <param name="SubmitPage">submit page for process payment page</param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.Access.WebPageUserControl.CreateWebPageItemLink(CARE.Access.WebPage,CARE.Access.CDBEnvironment,CARE.Access.CDBParameters)">
 <summary>
  Creates web page item link entry 
 </summary>
 <param name="pWP">Web page object</param>
 <param name="pEnv">Environment</param>
 <param name="pParams">Params</param>
 <remarks></remarks>
</member>
<member name="T:CARE.BulkMailerActvity">
 <summary>
 The mailing statistics associated with an individual
 </summary>
</member>
<member name="T:CARE.CsvReader">
 <summary>
 A data reader that is backed by a CSV file.
 </summary>
 <remarks>Column names are taken from the mandatory header record.  All column types are 
 string.  The Microsoft specific extension where dates are surrounded with hash marks ('#' 
 characters) is not supported.</remarks>
</member>
<member name="M:CARE.CsvReader.#ctor(System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.CsvReader" /> class.
 </summary>
 <param name="path">The path.</param>
</member>
<member name="M:CARE.CsvReader.Close">
 <summary>
 Closes the input file.
 </summary>
</member>
<member name="P:CARE.CsvReader.Depth">
 <summary>
 Gets a value indicating the depth of nesting for the current row.
 </summary>
 <returns>The level of nesting.</returns>
 <remarks>Nesting is not supported and so 0 is always returned.  This is in line with Microsoft recommendations.</remarks>
</member>
<member name="M:CARE.CsvReader.GetReferenceTable">
 <summary>
 Returns a <see cref="T:System.Data.DataTable" /> that has the same schema as the CSV file being read <see cref="T:System.Data.IDataReader" />.
 </summary><returns>
 A <see cref="T:System.Data.DataTable" /> that has the same schema as the CSV file.
 </returns>
 <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.IDataReader" /> is closed. </exception>
</member>
<member name="M:CARE.CsvReader.GetSchemaTable">
 <summary>
 Returns a <see cref="T:System.Data.DataTable" /> that describes the column metadata of the <see cref="T:System.Data.IDataReader" />.
 </summary><returns>
 A <see cref="T:System.Data.DataTable" /> that describes the column metadata.
 </returns>
 <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.IDataReader" /> is closed. </exception>
</member>
<member name="P:CARE.CsvReader.IsClosed">
 <summary>
 Gets a value indicating whether the data reader is closed.
 </summary>
 <returns>true if the data reader is closed; otherwise, false.</returns>
</member>
<member name="M:CARE.CsvReader.NextResult">
 <summary>
 Advances the data reader to the next result, when reading the results of batch SQL statements.
 </summary>
 <returns>true if there are more rows; otherwise, false.</returns>
 <remarks>Multiple result sets are not supported and so this always returns false.</remarks>
</member>
<member name="M:CARE.CsvReader.Read">
 <summary>
 Advances the <see cref="T:System.Data.IDataReader" /> to the next record.
 </summary>
 <returns> true if there are more rows; otherwise, false.</returns>
</member>
<member name="P:CARE.CsvReader.RecordsAffected">
 <summary>
 Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
 </summary>
 <returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the 
 statement failed; and -1 for SELECT statements.</returns>
 <remarks>Only select statements are suported and so this always returns -1.</remarks>
</member>
<member name="P:CARE.CsvReader.FieldCount">
 <summary>
 Gets the number of columns in the current row.
 </summary>
 <returns>When not positioned in a valid recordset, 0; otherwise, the number of columns in the current 
 record. The default is -1.</returns>
</member>
<member name="M:CARE.CsvReader.GetBoolean(System.Int32)">
 <summary>
 Gets the value of the specified column as a Boolean.
 </summary>
 <param name="i">The zero-based column ordinal.</param>
 <returns>The value of the column.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetByte(System.Int32)">
 <summary>
 Gets the 8-bit unsigned integer value of the specified column.
 </summary>
 <param name="i">The zero-based column ordinal.</param>
 <returns>The 8-bit unsigned integer value of the specified column.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
 <summary>
 Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.
 </summary>
 <param name="i">The zero-based column ordinal.</param>
 <param name="fieldOffset">The index within the field from which to start the read operation.</param>
 <param name="buffer">The buffer into which to read the stream of bytes.</param>
 <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation.</param>
 <param name="length">The number of bytes to read.</param>
 <returns>The actual number of bytes read.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetChar(System.Int32)">
 <summary>
 Gets the character value of the specified column.
 </summary>
 <param name="i">The zero-based column ordinal.</param>
 <returns>The character value of the specified column.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
 <summary>
 Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.
 </summary>
 <param name="i">The zero-based column ordinal.</param>
 <param name="fieldoffset">The index within the row from which to start the read operation.</param>
 <param name="buffer">The buffer into which to read the stream of bytes.</param>
 <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation.</param>
 <param name="length">The number of bytes to read.</param>
 <returns>The actual number of characters read.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetData(System.Int32)">
 <summary>
 Returns an <see cref="T:System.Data.IDataReader" /> for the specified column ordinal.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>An <see cref="T:System.Data.IDataReader" />.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
 <remarks>We do not suport embedded data and so this always returns nothing.</remarks>
</member>
<member name="M:CARE.CsvReader.GetDataTypeName(System.Int32)">
 <summary>
 Gets the data type information for the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The data type information for the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetDateTime(System.Int32)">
 <summary>
 Gets the date and time data value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The date and time data value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetDecimal(System.Int32)">
 <summary>
 Gets the fixed-position numeric value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The fixed-position numeric value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetDouble(System.Int32)">
 <summary>
 Gets the double-precision floating point number of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns> The double-precision floating point number of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetFieldType(System.Int32)">
 <summary>
 Gets the <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> 
 that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> 
 that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetFloat(System.Int32)">
 <summary>
 Gets the single-precision floating point number of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The single-precision floating point number of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetGuid(System.Int32)">
 <summary>
 Returns the GUID value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param><returns>
 The GUID value of the specified field.
 </returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetInt16(System.Int32)">
 <summary>
 Gets the 16-bit signed integer value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The 16-bit signed integer value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetInt32(System.Int32)">
 <summary>
 Gets the 32-bit signed integer value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The 32-bit signed integer value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetInt64(System.Int32)">
 <summary>
 Gets the 64-bit signed integer value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The 64-bit signed integer value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetName(System.Int32)">
 <summary>
 Gets the name for the field to find.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The name of the field or the empty string (""), if there is no value to return.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetOrdinal(System.String)">
 <summary>
 Return the index of the named field.
 </summary>
 <param name="name">The name of the field to find.</param>
 <returns>The index of the named field.</returns>
</member>
<member name="M:CARE.CsvReader.GetString(System.Int32)">
 <summary>
 Gets the string value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The string value of the specified field.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetValue(System.Int32)">
 <summary>
 Return the value of the specified field.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>The <see cref="T:System.Object" /> which will contain the field value upon return.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.GetValues(System.Object[])">
 <summary>
 Populates an array of objects with the column values of the current record.
 </summary>
 <param name="values">An array of <see cref="T:System.Object" /> to copy the attribute fields into.</param>
 <returns>The number of instances of <see cref="T:System.Object" /> in the array.</returns>
</member>
<member name="M:CARE.CsvReader.IsDBNull(System.Int32)">
 <summary>
 Return whether the specified field is set to null.
 </summary>
 <param name="i">The index of the field to find.</param>
 <returns>true if the specified field is set to null; otherwise, false.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="P:CARE.CsvReader.Item(System.Int32)">
 <summary>
 Gets the column located at the specified index.
 </summary>
 <returns>The column located at the specified index as an <see cref="T:System.Object" />.</returns>
   <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="P:CARE.CsvReader.Item(System.String)">
 <summary>
 Gets the column located at the specified index.
 </summary>
 <returns>The column located at the specified index as an <see cref="T:System.Object" />.</returns>
 <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception>
</member>
<member name="M:CARE.CsvReader.ReadRecord">
 <summary>
 Reads the record.
 </summary>
 <returns>a single <see cref="T:System.Data.DataRow" /> representing the next data record in the file.</returns>
</member>
<member name="M:CARE.CsvReader.Dispose(System.Boolean)">
 <summary>
 Releases unmanaged and - optionally - managed resources
 </summary>
 <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> 
 to release only unmanaged resources.</param>
</member>
<member name="M:CARE.CsvReader.Dispose">
 <summary>
 Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
 </summary>
</member>
<member name="T:CARE.Config.ConfigNameScope">
 <summary>
 This enum represents the different values that a Config Name's Config Scope can have
 </summary>
 <remarks>This is a flags enum.  
 As configs are always available to the system, its flag is 0.
 The actual value set against the config comes from a maintenance lookup, which should never be the exact values below, 
 but a bitwise combination of them.
 Expected stored values are
 </remarks>
</member>
<member name="T:CARE.Config.DatabasesCollectionHandler">
 <summary>
 The configuration section handler for the databases collection.
 </summary>
</member>
<member name="M:CARE.Config.DatabasesCollectionHandler.CreateNewElement">
 <summary>
 When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement" />.
 </summary>
 <returns>
 A new <see cref="T:System.Configuration.ConfigurationElement" />.
 </returns>
</member>
<member name="M:CARE.Config.DatabasesCollectionHandler.GetElementKey(System.Configuration.ConfigurationElement)">
 <summary>
 Gets the element key for a specified configuration element when overridden in a derived class.
 </summary>
 <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for.</param>
 <returns>
 An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.
 </returns>
</member>
<member name="P:CARE.Config.DatabasesCollectionHandler.Properties">
 <summary>
 Gets the collection of properties.
 </summary>
 <returns>The <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> of properties for the element.</returns>
</member>
<member name="P:CARE.Config.DatabasesCollectionHandler.CollectionType">
 <summary>
 Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
 </summary>
 <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> of this collection.</returns>
</member>
<member name="P:CARE.Config.DatabasesCollectionHandler.ElementName">
 <summary>
 Gets the name used to identify this collection of elements in the configuration file when overridden in a derived class.
 </summary>
 <returns>The name of the collection; otherwise, an empty string. The default is an empty string.</returns>
</member>
<member name="P:CARE.Config.DatabasesCollectionHandler.Item(System.Int32)">
 <summary>
 Gets or sets a property or attribute of this configuration element.
 </summary>
 <returns>The specified property, attribute, or child element.</returns>
   <param name="prop">The property to access. </param>
</member>
<member name="P:CARE.Config.DatabasesCollectionHandler.Item(System.String)">
 <summary>
 Gets or sets a property or attribute of this configuration element.
 </summary>
 <returns>The specified property, attribute, or child element.</returns>
   <param name="prop">The property to access. </param>
</member>
<member name="T:CARE.Config.AuthenticationValuesHandler">
 <summary>
 A class to get Authentication Values which are passed in Web Service calls. Currently usded by Postcoders QASOnDemand and AFD Evolution
 </summary>
</member>
<member name="M:CARE.Config.AuthenticationValuesHandler.#ctor">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Config.AuthenticationValuesHandler"/> class.
 </summary>
 <remarks>Prevent anything outside this assembly instanceating this class.</remarks>
</member>
<member name="P:CARE.Config.AuthenticationValuesHandler.Properties">
 <summary>
 Gets the collection of properties.
 </summary>
 <returns>The <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> of properties for the element.</returns>
</member>
<member name="P:CARE.Config.AuthenticationValuesHandler.UsernameValue">
 <summary>
 Gets the username.
 </summary>
 <value>
 The username/serial number.
 </value>
</member>
<member name="P:CARE.Config.AuthenticationValuesHandler.PasswordValue">
 <summary>
 Gets the password.
 </summary>
 <value>
 The password.
 </value>
</member>
<member name="T:CARE.Config.DbConfig">
 <summary>
 A class to describe an available database.
 </summary>
</member>
<member name="M:CARE.Config.DbConfig.#ctor">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.Config.DbConfig"/> class.
 </summary>
 <remarks>Prevent anything outside this assembly instanceating this class.</remarks>
</member>
<member name="P:CARE.Config.DbConfig.Properties">
 <summary>
 Gets the collection of properties.
 </summary>
 <returns>The <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> of properties for the element.</returns>
</member>
<member name="P:CARE.Config.DbConfig.Name">
 <summary>
 Gets the database name.
 </summary>
 <value>
 The dataabase name.
 </value>
</member>
<member name="P:CARE.Config.DbConfig.Description">
 <summary>
 Gets the database description.
 </summary>
 <value>
 The database description.
 </value>
</member>
<member name="P:CARE.Config.DbConfig.ConnectionStringName">
 <summary>
 Gets the connection string name.
 </summary>
 <value>
 The connection string name.
 </value>
</member>
<member name="P:CARE.Config.DbConfig.ClientCode">
 <summary>
 Gets the client code.
 </summary>
 <value>
 The client code.
 </value>
</member>
<member name="P:CARE.Config.DbConfig.InitialiseDatabaseFrom">
 <summary>
 Gets the initialise location.
 </summary>
 <value>
 The initialise location.
 </value>
 <remarks>This is the UNC path of the folder containing the administration files to create a new database</remarks>
</member>
<member name="P:CARE.Config.DbConfig.SqlLogQueueName">
 <summary>
 Gets the name of the SQL log queue.
 </summary>
 <value>
 The name of the SQL log queue.
 </value>
</member>
<member name="P:CARE.Config.DbConfig.SqlLogging">
 <summary>
 Gets the SQL logging mode.
 </summary>
 <value>
 The SQL logging mode.
 </value>
</member>
<member name="T:CARE.Config.NfpConfigrationManager">
 <summary>
 A helper class to simplify the use of the configuration data in the web.config file.
 </summary>
</member>
<member name="P:CARE.Config.NfpConfigrationManager.Databases">
 <summary>
 Gets the colection of <see cref="T:CARE.Config.DbConfig" /> database definition classes from the config file.
 </summary>
 <value>
 The database definitions.
 </value>
</member>
<member name="T:CARE.Config.NfpConfigSection">
 <summary>
 The NFP configuration section definition.
 </summary>
</member>
<member name="P:CARE.Config.NfpConfigSection.Properties">
 <summary>
 Gets the collection of properties.
 </summary>
 <returns>The <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> of properties for the element.</returns>
</member>
<member name="P:CARE.Config.NfpConfigSection.Databases">
 <summary>
 Gets the colection of <see cref="T:CARE.Config.DbConfig" /> database definition classes.
 </summary>
 <value>
 The database definitions.
 </value>
</member>
<member name="T:CARE.CertificateDataProcessor">
 <summary>
 Class to enable the processing of raw exam certificate data into the system
 </summary>
</member>
<member name="M:CARE.CertificateDataProcessor.#ctor(CARE.Access.CDBEnvironment,System.Data.IDataReader,CARE.Access.ExamUnitCertRunType)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.CertificateDataProcessor"/> class.
 </summary>
 <param name="environemnt">The <see cref="T:CARE.Access.CDBEnvironment" /> associated with this session.</param>
 <param name="dataSource">The <see cref="T:System.Data.IDataReader" /> containing the raw data.</param>
 <param name="runType">The <see cref="T:CARE.Access.ExamUnitCertRunType" /> being used for this certificate run.</param>
</member>
<member name="P:CARE.CertificateDataProcessor.DataSource">
 <summary>
 Gets the data source.
 </summary>
 <value>
 The <see cref="T:System.Data.IDataReader" /> containing the raw data.
 </value>
</member>
<member name="P:CARE.CertificateDataProcessor.Environment">
 <summary>
 Gets the environment.
 </summary>
 <value>
 The <see cref="T:CARE.Access.CDBEnvironment" /> associated with this session.
 </value>
</member>
<member name="P:CARE.CertificateDataProcessor.CsvWriter">
 <summary>
 Gets or sets the CSV writer.
 </summary>
 <value>
 The <see cref="P:CARE.CertificateDataProcessor.CsvWriter" /> to be used when outputting the processed data.
 </value>
</member>
<member name="P:CARE.CertificateDataProcessor.StreamWriter">
 <summary>
 Gets or sets the stream writer.
 </summary>
 <value>
 The <see cref="P:CARE.CertificateDataProcessor.StreamWriter" /> to which the processed data will be written in CSV format.
 </value>
</member>
<member name="P:CARE.CertificateDataProcessor.RunType">
 <summary>
 Gets the run type.
 </summary>
 <value>
 The <see cref="T:CARE.Access.ExamUnitCertRunType" /> being used for this certificate run.
 </value>
</member>
<member name="M:CARE.CertificateDataProcessor.Process">
 <summary>
 Processes the data in the data source.
 </summary>
 <remarks>
 The data contained in the <see cref="P:CARE.CertificateDataProcessor.DataSource" /> will have the certificate number, certificate number prefix and certificate number
 columns overwritten with the correct, system generated values and the data will be written to the database.  In addition, if the data source
 has a column named standard_document, it will be overwritten with the standard document code from the <see cref="P:CARE.CertificateDataProcessor.RunType" />.   Also, if 
 <see cref="P:CARE.CertificateDataProcessor.StreamWriter" /> is set, the processed data will written in CSV format to the <see cref="T:System.IO.StreamWriter" /> object
 specified.
 </remarks>
</member>
<member name="M:CARE.CertificateDataProcessor.GetAttributes(System.Data.DataRow)">
 <summary>
 Gets the attributes.
 </summary>
 <param name="data">The <see cref="T:System.Data.DataRow" /> to get the attributes from.</param>
 <returns>An <see cref="T:System.Collections.IEnumerable" /> containing a key value pair for each of the arbitrary attributes on the passed <see cref="T:System.Data.DataRow" />.</returns>
</member>
<member name="M:CARE.CertificateDataProcessor.IsAttributeColumn(System.String)">
 <summary>
 Determines whether the specified column is an arbitrary attribute column.
 </summary>
 <param name="columnName">Name of the column.</param>
 <returns><c>true</c> if the column is arbitrary data; otherwise, <c>false</c></returns>
</member>
<member name="M:CARE.CertificateDataProcessor.WriteCsvData(System.Data.DataRow)">
 <summary>
 Writes data to the output <see cref="P:CARE.CertificateDataProcessor.CsvWriter" /> if on has been specified.
 </summary>
 <param name="data">The <see cref="T:System.Data.DataRow" /> containing the data to be written.</param>
</member>
<member name="P:CARE.CsvWriter.StreamWriter">
 <summary>
 Gets or sets the stream writer.
 </summary>
 <value>
 The stream writer that the CSV data is to be written to.
 </value>
</member>
<member name="P:CARE.CsvWriter.AreHeadersWritten">
 <summary>
 Gets or sets a value indicating whether column headers have been written.
 </summary>
 <value>
   <c>true</c> if a header record has been written; otherwise, <c>false</c>.
 </value>
</member>
<member name="M:CARE.CsvWriter.#ctor(System.IO.StreamWriter)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.CsvWriter"/> class.
 </summary>
 <param name="stream">The <see cref="P:CARE.CsvWriter.StreamWriter" /> to write the CSV data to.</param>
</member>
<member name="M:CARE.CsvWriter.Write(System.Data.DataRow)">
 <summary>
 Writes the specified data to the output stream.
 </summary>
 <param name="data">The <see cref="T:System.Data.DataRow" /> containing the data to be written.</param>
</member>
<member name="M:CARE.CsvWriter.WriteHeaders(System.Data.DataColumnCollection)">
 <summary>
 Writes the headers.
 </summary>
 <param name="columns">The <see cref="T:System.Data.DataColumnCollection" /> specifying the columns to write headers for.</param>
</member>
<member name="M:CARE.CsvWriter.WriteData(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Writes the data.
 </summary>
 <param name="data">The <see cref="T:System.Data.DataRow" /> contain the data to be written.</param>
</member>
<member name="M:CARE.BulkUpdater.SaveBulkUpdate(CARE.Data.SQLStatement)">
 <summary>Save the changes in bulk.</summary>
 <param name="pSQLStatement">The SQL statement required by the BulkUpdate</param>
</member>
<member name="M:CARE.CARERecordFactory.#ctor">
 <summary>
 This method is non-private to allow people to use as many instances as they want where needed.
 There should really be no need and you should used the Instance property, but there is no reason why a factory should be a singleton
 </summary>
</member>
<member name="T:CARE.IDbLoadable">
 <summary>
 Implement this interface if your class can be loaded from a DataRow
 </summary>
 <remarks>See the CARERecordFactory for more information about how this is used.
 The name of this interface isn't great, but it's the least of the bad ones we could come up with.  Please feel free to change
 </remarks>
</member>
<member name="T:CARE.IDbSelectable">
 <summary>
 Implement this interface if you want your class to be loaded by the CARERecordFactory.
 </summary>
 <remarks>See the CARERecordFactory for more information about how this is used.
 The name of this interface isn't great, but it's the least of the bad ones we could come up with.  Please feel free to change
 </remarks>
</member>
<member name="T:CARE.DateExtensions">
 <summary>
 A module containing Date class extension methods
 </summary>
</member>
<member name="M:CARE.DateExtensions.NextWorkingDay(System.DateTime,CARE.Access.CDBEnvironment)">
 <summary>
 Gets the next the working day.
 </summary>
 <param name="value">The starting date.</param>
 <param name="environment">The environment.</param>
 <returns>A new <see cref="T:System.DateTime" /> object representing the earliest date that is a working day on or after the date provided.</returns>
</member>
<member name="M:CARE.DateExtensions.PreviousWorkingDay(System.DateTime,CARE.Access.CDBEnvironment)">
 <summary>
 Gets the previous the working day.
 </summary>
 <param name="value">The starting date.</param>
 <param name="environment">The environment.</param>
 <returns>A new <see cref="T:System.DateTime" /> object representing the latest date that is a working day on or before the date provided.</returns>
</member>
<member name="M:CARE.DateExtensions.AdjustToWorkingDay(System.DateTime,CARE.Access.CDBEnvironment,System.Int32)">
 <summary>
 Adjusts the supplied date by the amount given until the resulting date is a working day.
 </summary>
 <param name="value">The date.</param>
 <param name="environment">The environment.</param>
 <param name="adjustment">The amount to adjust by.</param>
 <returns>A new <see cref="T:System.DateTime" /> object representing the adjusted date.</returns>
</member>
<member name="M:CARE.DateExtensions.IsWeekend(System.DateTime)">
 <summary>
 Determines whether the specified date is a working day.
 </summary>
 <param name="value">The date.</param>
 <returns>True if the specified date fals in the weekend, otherwise False</returns>
</member>
<member name="M:CARE.DateExtensions.IsBankHoliday(System.DateTime,CARE.Access.CDBEnvironment)">
 <summary>
 Determines whether the specified date is a bank holiday.
 </summary>
 <param name="value">The date.</param>
 <param name="environment">The environment.</param>
 <returns>True if the specified date is a bank holiday, otherwise False</returns>
</member>
<member name="M:CARE.DateExtensions.IsWorkingDay(System.DateTime,CARE.Access.CDBEnvironment)">
 <summary>
 Determines whether the specified date is a working day.
 </summary>
 <param name="value">The date.</param>
 <param name="environment">The environment.</param>
 <returns>True if the specified date is a working day, otherwise False</returns>
</member>
<member name="P:CARE.VSeriesAccountValidation.SortCodeInput">
 <summary>Sort Code to be validated.</summary>
</member>
<member name="P:CARE.VSeriesAccountValidation.AccountNumberInput">
 <summary>Account Number to be validated.</summary>
</member>
<member name="P:CARE.VSeriesAccountValidation.VerifyType">
 <summary>The type of verification to be applied.  The default is None.</summary>
</member>
<member name="P:CARE.VSeriesAccountValidation.VerifyURL">
 <summary>The URL required for Account Validation.</summary>
</member>
<member name="M:CARE.ExamAccreditationFilter.BuildHierarchicalList(CARE.Data.SQLStatement)">
 <summary>
 Returns a list of ExamUnitLinkIds built from a SQL Statement returning all un-accredited units.  The function also includes all child records of unaccredited parents
 </summary>
 <param name="vSQL">SQL Statement that will return a table of all unaccredited unit links.  Must contain a column named exam_unit_link_id</param>
 <returns>A List of all ExamUnitLinkIds that are in the ExamUnitLinks Dictionary (from the Constructor) and that are also returned by the unaccredited rows returned by the SQL Statement</returns>
 <remarks>All ExamUnitLinkIds that are returned by the SQL Statement will be returned.  All descendents of those ExamUnitLinkIds will also be returned</remarks>
</member>
<member name="T:CARE.CardAuthorisationServiceFactory">
 <summary>
 Create an instance of the Card Authorisation service 
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.CardAuthorisationServiceFactory.GetAuthorisationServiceProvider(CARE.Access.CDBEnvironment,System.String)">
 <summary>
 
 </summary>
 <param name="pEnv"></param>
 <param name="pBatchCategory"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.CardAuthorisationServiceFactory.GetAuthorisationServiceProvider(CARE.Access.CDBEnvironment,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="pEnv"></param>
 <param name="pBatchCategory"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.CardAuthorisationServiceFactory.GetAuthorisationServiceProvider(CARE.Access.CDBEnvironment,CARE.Access.CardSale)">
 <summary>
 
 </summary>
 <param name="pEnv"></param>
 <param name="pCardSale"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="M:CARE.CardAuthorisationServiceFactory.GetAuthorisationServiceProvider(CARE.Access.CDBEnvironment,CARE.Access.CardSale,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="pEnv"></param>
 <param name="pCardSale"></param>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="T:CARE.CardSettings">
 <summary>
 This card will read the Card Setting information from DataBase \ Configuration and set the details required  
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.CardSettings.#ctor(CARE.Access.CDBEnvironment,CARE.Access.CardSale,System.String,System.String)">
 <summary>
 
 </summary>
 <param name="pEnv"></param>
 <param name="pCardSale"></param>
 <param name="pBatchCategory"></param>
 <remarks></remarks>
</member>
<member name="M:CARE.CardSettings.Init">
 <summary>
 Method to initialise the merchant details  
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.CardSettings.IncorrectSetup">
 <summary>
 
 </summary>
 <remarks></remarks>
</member>
<member name="M:CARE.CardSettings.GetMerchantRetailNumber">
 <summary>
 
 </summary>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.TimeOut">
 <summary>
 Property to read the user defined TimeOut time from the configuration. Application will use this before timing out if the service provider's
 server does not respond back with the validation results 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.GatewayHostAddress">
 <summary>
 Property to read the host url inforation for the authorisation service provider
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.MerchantID">
 <summary>
 Property to read the Merchant ID from the batch categories or merchant details table. 
 If this is not set then application will raise an error. 
 </summary>
 <value></value>
 <returns>Merchant ID</returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.GatewayActionAddress">
 <summary>
 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.ReturnAddress">
 <summary>
 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.GatewayPassword">
 <summary>
 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.CardAuthorisationServiceType">
 <summary>
 
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
</member>
<member name="P:CARE.CardSettings.Currency">
 <summary>
 Currency code from the financial controls
 </summary>
 <value></value>
 <returns></returns>
 <remarks>Currently only support GBP</remarks>
</member>
<member name="M:CARE.SagePayHostedPayment.ParseRequestData(CARE.Collections.ParameterList)">
 <summary>
 This function formats the request data into format required by SAGEPAYHOSTED
 </summary>
 <returns>Request data in the format require by the SAGEPAYHOSTED</returns>
 <remarks></remarks>
</member>
<member name="T:CARE.SecureCXLRequest.VPCStringComparer">
 <summary>
 Customised Compare Class
 </summary>
 <para>
 The Virtual Payment Client need to use an Ordinal comparison to Sort on 
 the field names to create the MD5 Signature for validation of the message. 
 This class provides a Compare method that is used to allow the sorted list 
 to be ordered imports an Ordinal comparison.
 </para>
 <remarks></remarks>
</member>
<member name="M:CARE.SecureCXLRequest.VPCStringComparer.Compare(System.String,System.String)">
 <summary>
 Compare method imports Ordinal comparison
 </summary>
 <param name="x">The first string in the comparison.</param>
 <param name="y">The second string in the comparison.</param>
 <returns></returns>
 <remarks>An int containing the result of the comparison.</remarks>
</member>
<member name="T:CARE.DocumentInfo">
 <summary>
 Document informnation required to run a mailing fulfilment.
 </summary>
</member>
<member name="M:CARE.DocumentInfo.#ctor(CARE.Access.CDBEnvironment,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.String)">
 <summary>
 Initializes a new instance of the <see cref="T:CARE.DocumentInfo"/> class.
 </summary>
 <param name="pEnv">The environment to use.</param>
 <param name="pMailingTemplate">The mailing template to filter on.</param>
 <param name="pCreatedBy">The creators log name to filter on.</param>
 <param name="pCreatedOn">The date created to filter on.</param>
 <param name="pContactNumber">The contact number to filter on.</param>
 <param name="pBatchNumber">The batch number to filter on.</param>
 <param name="pTransactionNumber">The transaction number to filter on.</param>
 <remarks>When instanciated, the fulfulment history for this run.</remarks>
</member>
<member name="M:CARE.DocumentInfo.GetInstance(CARE.Access.CDBEnvironment,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.String)">
 <summary>
 Get a new instance of the <see cref="T:CARE.DocumentInfo"/> class.
 </summary>
 <param name="pEnv">The environment to use.</param>
 <param name="pMailingTemplate">The mailing template to filter on.</param>
 <param name="pCreatedBy">The creators log name to filter on.</param>
 <param name="pCreatedOn">The date created to filter on.</param>
 <param name="pContactNumber">The contact number to filter on.</param>
 <param name="pBatchNumber">The batch number to filter on.</param>
 <param name="pTransactionNumber">The transaction number to filter on.</param>
 <remarks>This method is used to get a new <see cref="T:CARE.DocumentInfo"/> object so that the object is only
 created if appropriate for the parameters given.  If no appropriate data is found then no object
 reference is returned.</remarks>
</member>
<member name="P:CARE.DocumentInfo.SelectionFilter">
 <summary>
 Gets the selection filter.
 </summary>
 <value>
 The selection filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RequestedMailingTemplate">
 <summary>
 Gets the requested mailing template.
 </summary>
 <value>
 The requested mailing template.
 </value>
</member>
<member name="P:CARE.DocumentInfo.CreatedBy">
 <summary>
 Gets the creator filter.
 </summary>
 <value>
 The created filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.CreatedOn">
 <summary>
 Gets the created on filter.
 </summary>
 <value>
 The created on filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.ContactNumber">
 <summary>
 Gets the contact number filter.
 </summary>
 <value>
 The contact number filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.BatchNumber">
 <summary>
 Gets the batch number filter.
 </summary>
 <value>
 The batch number filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.TransactionNumber">
 <summary>
 Gets the transaction number filter.
 </summary>
 <value>
 The transaction number filter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.MailingTemplateCode">
 <summary>
 Gets the mailing template code.
 </summary>
 <value>
 The mailing template code.
 </value>
</member>
<member name="P:CARE.DocumentInfo.StandardDocument">
 <summary>
 Gets the standard document.
 </summary>
 <value>
 The standard document.
 </value>
</member>
<member name="P:CARE.DocumentInfo.Package">
 <summary>
 Gets the package.
 </summary>
 <value>
 The package.
 </value>
</member>
<member name="P:CARE.DocumentInfo.Extension">
 <summary>
 Gets the extenstion.
 </summary>
 <value>
 The extenstion.
 </value>
</member>
<member name="P:CARE.DocumentInfo.SelectedParagraphs">
 <summary>
 Gets the selected paragraphs.
 </summary>
 <value>
 The selected paragraphs.
 </value>
</member>
<member name="P:CARE.DocumentInfo.MailingDocumentNumber">
 <summary>
 Gets the mailing document number.
 </summary>
 <value>
 The mailing document number.
 </value>
</member>
<member name="P:CARE.DocumentInfo.StandardDocuments">
 <summary>
 Gets the standard documents.
 </summary>
 <value>
 The standard documents.
 </value>
</member>
<member name="P:CARE.DocumentInfo.Printers">
 <summary>
 Gets the printers.
 </summary>
 <value>
 The printers.
 </value>
</member>
<member name="P:CARE.DocumentInfo.MailmergeHeaders">
 <summary>
 Gets the mailmerge headers.
 </summary>
 <value>
 The mailmerge headers.
 </value>
</member>
<member name="P:CARE.DocumentInfo.BookMarks">
 <summary>
 Gets the book marks.
 </summary>
 <value>
 The book marks.
 </value>
</member>
<member name="P:CARE.DocumentInfo.DocumentList">
 <summary>
 Gets the document list.
 </summary>
 <value>
 The document list.
 </value>
</member>
<member name="P:CARE.DocumentInfo.ReportCode">
 <summary>
 Gets the report code.
 </summary>
 <value>
 The report code.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP1">
 <summary>
 Gets the first report parameter.
 </summary>
 <value>
 The first report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP2">
 <summary>
 Gets the secomd report parameter.
 </summary>
 <value>
 The second report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP3">
 <summary>
 Gets the third report parameter.
 </summary>
 <value>
 The third report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP4">
 <summary>
 Gets the fourth report parameter.
 </summary>
 <value>
 The fourth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP6">
 <summary>
 Gets the sixth report parameter.
 </summary>
 <value>
 The sixth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP7">
 <summary>
 Gets the seventh report parameter.
 </summary>
 <value>
 The seventh report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP8">
 <summary>
 Gets the eight report parameter.
 </summary>
 <value>
 The eigth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP9">
 <summary>
 Gets the ninth report parameter.
 </summary>
 <value>
 The ninth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP10">
 <summary>
 Gets the tenth report parameter.
 </summary>
 <value>
 The tenth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP11">
 <summary>
 Gets the eleventh report parameter.
 </summary>
 <value>
 The eleventh report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.RP12">
 <summary>
 Gets the twelfth report parameter.
 </summary>
 <value>
 The twelfth report parameter.
 </value>
</member>
<member name="P:CARE.DocumentInfo.DataFileName">
 <summary>
 Gets the name of the data file.
 </summary>
 <value>
 The name of the data file.
 </value>
</member>
<member name="P:CARE.DocumentInfo.FulfillmentNumber">
 <summary>
 Gets the fulfillment number.
 </summary>
 <value>
 The fulfillment number.
 </value>
</member>
<member name="P:CARE.DocumentInfo.DataRow">
 <summary>
 Gets the data and sets up the fulfilment history document list.
 </summary>
 <value>
 The data row.
 </value>
</member>
<member name="P:CARE.DocumentInfo.ContactMailingDocument">
 <summary>
 Gets the contact mailing document.
 </summary>
 <value>
 The contact mailing document.
 </value>
</member>
<member name="P:CARE.DocumentInfo.ExternalApplication">
 <summary>
 Gets the contact mailing document.
 </summary>
 <value>
 The contact mailing document.
 </value>
</member>
<member name="P:CARE.DocumentInfo.MailingTemplate">
 <summary>
 Gets the mailing template.
 </summary>
 <value>
 The mailing template.
 </value>
</member>
<member name="P:CARE.DocumentInfo.FulfillmentHistory">
 <summary>
 Gets the fulfillment history.
 </summary>
 <value>
 The fulfillment history.
 </value>
</member>
<member name="T:CARE.CMTPricing">
 <summary>Used by Change Membership Type (CMT) to calculate the price to be charged for each membership detail line.</summary>
</member>
<member name="M:CARE.CMTPricing.#ctor(CARE.Access.CDBEnvironment,CARE.Access.Contact,System.DateTime,System.DateTime,CARE.Access.MembershipType,CARE.Access.PaymentFrequency,CARE.CMTPricing.CMTOldOrNewMemberType)">
 <summary>Initialise new CMTPricing class with common defaults.</summary>
 <param name="pPayer">Current Membership Payer.</param>
 <param name="pCMTDate">Date CMT and prorating takes effect.</param>
 <param name="pJoinedDate">New membership joined date</param>
 <remarks></remarks>
</member>
<member name="M:CARE.CMTPricing.GetDetailPrice(CARE.Access.PaymentPlanDetail.PaymentPlanDetailTypes,System.Double@,System.Double@)">
 <summary>Get the balance etc. for all detail lines of the specified line type.</summary>
</member>
<member name="T:CARE.CDBEmailAttachment">
 <summary>
 A class to represent a miscellaneous attachment
 </summary>
</member>
<member name="P:CARE.CDBEmailAttachment.Id">
 <summary>
 The system wide identifier of the attachment.
 </summary>
 <value>
 The attachment's identifier.
 </value>
 <remarks>This is intended to allow an existing <see cref="T:CARE.CDBEmailAttachment" /> to be attached to an email.  
 In normal use this should be set to zero.</remarks>
</member>
<member name="P:CARE.CDBEmailAttachment.Name">
 <summary>
 The name of the attachment.
 </summary>
 <value>
 The attachment's name.
 </value>
 <remarks>Usually a filename for the attached data.</remarks>
</member>
<member name="P:CARE.CDBEmailAttachment.Content">
 <summary>
 The content of the attachment.
 </summary>
 <value>
 The attachment's content.
 </value>
</member>
<member name="T:CARE.CDBEmailContent">
 <summary>
 A class used to represent an archived email and it's attachemnts
 </summary>
</member>
<member name="P:CARE.CDBEmailContent.Content">
 <summary>
 The body of the email.
 </summary>
 <value>
 The email body content.
 </value>
</member>
<member name="P:CARE.CDBEmailContent.IsBodyHtml">
 <summary>
 A value indicating whether the email body contains HTML.
 </summary>
 <value>
 <c>true</c> if the body contains HTML; otherwise, <c>false</c>.
 </value>
</member>
<member name="P:CARE.CDBEmailContent.Attachments">
 <summary>
 The attachments attached to this email.
 </summary>
 <value>
 The attachments.
 </value>
</member>
</members>
</doc>
