Imports System.Collections.ObjectModel
Imports System.Collections.Specialized
Imports System.Linq

Namespace Access

  Public Class DeclarationLinesUnclaimed
    Inherits CARERecord

    Private mvGiftAidDeclaration As GiftAidDeclaration
    Private mvBTA As BatchTransactionAnalysis
#Region "AutoGenerated Code"

    '--------------------------------------------------
    'Enum defining all the fields in the table
    '--------------------------------------------------
    Private Enum ClassFieldItems
      AllFields = 0
      CdNumber
      ContactNumber
      BatchNumber
      TransactionNumber
      LineNumber
      DeclarationOrCovenantNumber
      NetAmount
    End Enum

    '--------------------------------------------------
    'Required overrides for the class
    '--------------------------------------------------
    Protected Overrides Sub AddFields()
      With Me.ClassFields
        .Add("cd_number", CDBField.FieldTypes.cftInteger)
        .Add("contact_number", CDBField.FieldTypes.cftInteger)
        .Add("batch_number", CDBField.FieldTypes.cftInteger)
        .Add("transaction_number", CDBField.FieldTypes.cftInteger)
        .Add("line_number", CDBField.FieldTypes.cftInteger)
        .Add("declaration_or_covenant_number")
        .Add("net_amount", CDBField.FieldTypes.cftNumeric)

        .Item(ClassFieldItems.BatchNumber).PrimaryKey = True

        .Item(ClassFieldItems.TransactionNumber).PrimaryKey = True

        .Item(ClassFieldItems.LineNumber).PrimaryKey = True

        .Item(ClassFieldItems.DeclarationOrCovenantNumber).PrimaryKey = True

        .Item(ClassFieldItems.CdNumber).PrefixRequired = True
      End With

      'I don't know why we don't always prefix our columns - surely avoiding confusion should always be promoted
      Me.ClassFields.Cast(Of ClassField).ToList().ForEach(Sub(vField) vField.PrefixRequired = True)
    End Sub

    Protected Overrides Sub SetDefaults()
      MyBase.SetDefaults()
      Me.DeclarationOrCovenantNumber = "D"
    End Sub

    Protected Overrides ReadOnly Property SupportsAmendedOnAndBy As Boolean
      Get
        Return False
      End Get
    End Property
    Protected Overrides ReadOnly Property TableAlias As String
      Get
        Return "dlu"
      End Get
    End Property
    Protected Overrides ReadOnly Property DatabaseTableName As String
      Get
        Return "declaration_lines_unclaimed"
      End Get
    End Property

    '--------------------------------------------------
    'Default constructor
    '--------------------------------------------------
    Public Sub New(ByVal pEnv As CDBEnvironment)
      MyBase.New(pEnv)
    End Sub

    '--------------------------------------------------
    'Public property procedures
    '--------------------------------------------------
    Public Property CdNumber As Integer
      Get
        Return ClassFields(ClassFieldItems.CdNumber).IntegerValue
      End Get
      Private Set(value As Integer)
        ClassFields(ClassFieldItems.CdNumber).IntegerValue = value
      End Set
    End Property
    Public Property ContactNumber As Integer
      Get
        Return ClassFields(ClassFieldItems.ContactNumber).IntegerValue
      End Get
      Private Set(value As Integer)
        ClassFields(ClassFieldItems.ContactNumber).IntegerValue = value
      End Set
    End Property
    Public Property BatchNumber As Integer
      Get
        Return ClassFields(ClassFieldItems.BatchNumber).IntegerValue
      End Get
      Private Set(value As Integer)
        ClassFields(ClassFieldItems.BatchNumber).IntegerValue = value
      End Set
    End Property
    Public Property TransactionNumber As Integer
      Get
        Return ClassFields(ClassFieldItems.TransactionNumber).IntegerValue
      End Get
      Private Set(value As Integer)
        ClassFields(ClassFieldItems.TransactionNumber).IntegerValue = value
      End Set
    End Property
    Public Property LineNumber As Integer
      Get
        Return ClassFields(ClassFieldItems.LineNumber).IntegerValue
      End Get
      Private Set(value As Integer)
        ClassFields(ClassFieldItems.LineNumber).IntegerValue = value
      End Set
    End Property
    Public Property DeclarationOrCovenantNumber As String
      Get
        Return ClassFields(ClassFieldItems.DeclarationOrCovenantNumber).Value
      End Get
      Private Set(value As String)
        ClassFields(ClassFieldItems.DeclarationOrCovenantNumber).Value = value
      End Set
    End Property
    Public Property NetAmount As Double
      Get
        Return ClassFields(ClassFieldItems.NetAmount).DoubleValue
      End Get
      Private Set(value As Double)
        ClassFields(ClassFieldItems.NetAmount).DoubleValue = value
      End Set
    End Property
#End Region

#Region "Non Auto-Generated Code"
    Public Overloads Sub InitFromRecordSet(ByVal pRecordSet As CDBRecordSet)
      Dim vFields As CDBFields

      InitClassFields()
      vFields = pRecordSet.Fields
      mvExisting = True
      With mvClassFields
        'Always include the primary key attributes
        .SetItem(ClassFieldItems.BatchNumber, vFields)
        .SetItem(ClassFieldItems.TransactionNumber, vFields)
        .SetItem(ClassFieldItems.LineNumber, vFields)
        .SetItem(ClassFieldItems.NetAmount, vFields)
        .SetItem(ClassFieldItems.CdNumber, vFields)
        .SetItem(ClassFieldItems.DeclarationOrCovenantNumber, vFields)
        .SetItem(ClassFieldItems.ContactNumber, vFields)
      End With
    End Sub

    Public Property GiftAidDeclaration As GiftAidDeclaration
      Get
        If mvGiftAidDeclaration Is Nothing Then
          Dim vDecl As GiftAidDeclaration = GetGiftAidDeclarationInstance()
          If vDecl IsNot Nothing AndAlso Me.CdNumber <> vDecl.DeclarationNumber Then Me.CdNumber = vDecl.DeclarationNumber
          Me.GiftAidDeclaration = vDecl
        End If
        Return mvGiftAidDeclaration
      End Get
      Private Set(value As GiftAidDeclaration)
        mvGiftAidDeclaration = value
      End Set
    End Property

    Overloads Sub InitClassFields()
      MyBase.InitClassFields()
      Me.GiftAidDeclaration = Nothing
      Me.BatchTransactionAnalysis = Nothing
    End Sub

    Private Function GetGiftAidDeclarationInstance() As GiftAidDeclaration
      Dim vResult As GiftAidDeclaration = Nothing
      If Me.CdNumber > 0 Then
        Dim vTest As New GiftAidDeclaration()
        vTest.Init(Me.Environment, Me.CdNumber)
        If vTest IsNot Nothing AndAlso vTest.Existing Then vResult = vTest
      ElseIf Me.ContactNumber > 0 AndAlso Me.BatchTransaction IsNot Nothing
        Dim vTest As New GiftAidDeclaration
        vTest.InitFromContact(Me.Environment, Me.ContactNumber, Me.BatchTransaction.TransactionDate.ToString(), Me.BatchTransactionAnalysis.PaymentPlanNumber, Me.BatchTransactionAnalysis.BatchNumber, Me.BatchTransactionAnalysis.TransactionNumber)
        If vTest.Existing Then vResult = vTest
      End If
      Return vResult
    End Function

    Public Overloads Sub Init(Optional ByRef pBatchNumber As Integer = 0, Optional ByRef pTransactionNumber As Integer = 0, Optional ByRef pLineNumber As Integer = 0, Optional ByRef pDecOrCovNumber As String = "")
      Dim vRecordSet As CDBRecordSet

      If pBatchNumber > 0 Then
        vRecordSet = Me.Environment.Connection.GetRecordSet("SELECT " & GetRecordSetFields() & " FROM declaration_lines_unclaimed dlu WHERE batch_number = " & pBatchNumber & " AND transaction_number = " & pTransactionNumber & " AND line_number = " & pLineNumber & " AND declaration_or_covenant_number = '" & pDecOrCovNumber & "'")
        If vRecordSet.Fetch() = True Then
          InitFromRecordSet(vRecordSet)
        Else
          MyBase.Init()
        End If
        vRecordSet.CloseRecordSet()
      Else
        MyBase.Init()
      End If

    End Sub


    Public Sub InitFromOverPaidClaimLine(ByVal pClaimLine As ITaxClaimLine, ByVal pDeclaration As GiftAidDeclaration, ByVal pContactNumber As Integer, ByVal pAmount As Double)
      Init()
      'First check not already existing
      Init(pClaimLine.BatchNumber, pClaimLine.TransactionNumber, pClaimLine.LineNumber, "D")
      If Existing = False Then
        Me.CdNumber = pDeclaration.DeclarationNumber
        Me.ContactNumber = pContactNumber
        Me.BatchNumber = pClaimLine.BatchNumber
        Me.TransactionNumber = pClaimLine.TransactionNumber
        Me.LineNumber = pClaimLine.LineNumber
        Me.DeclarationOrCovenantNumber = "D"
        Me.NetAmount = pAmount
      End If
    End Sub

    Public Sub CreateNewNegativeLines(ByVal pNewBatch As Integer, ByVal pNewTransaction As Integer, ByVal pNewline As Integer, ByVal pOrigBatch As Integer, ByVal pOrigTransaction As Integer, Optional ByVal pOrigLine As Integer = 0)
      Dim vSQL As String
      Dim vIndex As Integer
      Dim vType As String
      Dim vWhereFields As New CDBFields
      Dim vDLU As New DeclarationLinesUnclaimed(Me.Environment)
      Dim vRS As CDBRecordSet
      Dim vDT As New CDBDataTable
      Dim vDR As CDBDataRow
      Dim vAdjustmentTotal As Double
      Dim vAdjustmentCount As Integer
      Dim vFirstRecord As Boolean
      Dim vAdjustmentReferences As Collection
      Dim vDeclarationNumber As Integer

      For vIndex = 0 To 1
        vType = If(vIndex = 0, "D", "C")
        vSQL = "SELECT cd_number,contact_number,net_amount,line_number"
        vSQL = vSQL & " FROM declaration_tax_claim_lines dtcl, " & If(vType = "D", "gift_aid_declarations gad", "covenants c")
        vSQL = vSQL & " WHERE dtcl.batch_number = " & pOrigBatch & " AND dtcl.transaction_number = " & pOrigTransaction
        If pOrigLine > 0 Then vSQL = vSQL & " AND line_number = " & pOrigLine
        vSQL = vSQL & " AND declaration_or_covenant_number = '" & vType & "' AND dtcl.cd_number = " & If(vType = "D", "gad.declaration_number", "c.covenant_number")

        vRS = mvEnv.Connection.GetRecordSet(vSQL)

        vFirstRecord = True
        While vRS.Fetch() = True
          vDeclarationNumber = vRS.Fields(1).IntegerValue
          If vFirstRecord = True And vType = "D" Then
            'BR 11524: We are looking at the first BTA for this Declaration, fill Data Table with any
            'GC adjustment records for this Contact.
            With vWhereFields
              .Clear()
              .Add("b.batch_type", CDBField.FieldTypes.cftCharacter, Batch.GetBatchTypeCode(Batch.BatchTypes.GiftAidClaimAdjustment), CDBField.FieldWhereOperators.fwoEqual)
              .Add("bt.batch_number", CDBField.FieldTypes.cftLong, "b.batch_number", CDBField.FieldWhereOperators.fwoEqual)
              .Add("bt.contact_number", CDBField.FieldTypes.cftLong, vRS.Fields(2).IntegerValue)
              .Add("bta.batch_number", CDBField.FieldTypes.cftLong, "bt.batch_number", CDBField.FieldWhereOperators.fwoEqual)
              .Add("bta.transaction_number", CDBField.FieldTypes.cftLong, "bt.transaction_number", CDBField.FieldWhereOperators.fwoEqual)
            End With
            vSQL = "SELECT bta.notes,bta.amount,bta.batch_number,bta.transaction_number,bta.line_number,bta.member_number FROM batches b, batch_transactions bt, batch_transaction_analysis bta WHERE " & mvEnv.Connection.WhereClause(vWhereFields) & " ORDER BY bta.batch_number, bta.transaction_number, bta.line_number"
            vDT.FillFromSQLDONOTUSE(mvEnv, vSQL, "Notes,Amount,Batch_Number,Transaction_Number,Line_Number,Member_Number")
            vFirstRecord = False
          End If

          vAdjustmentTotal = 0
          vAdjustmentCount = 0
          vAdjustmentReferences = New Collection

          For Each vDR In vDT.Rows
            If vDR.Item("Notes") = pOrigBatch & "/" & pOrigTransaction & "/" & vRS.Fields(4).IntegerValue Then
              vAdjustmentReferences.Add(vDR.Item("Batch_Number") & "/" & vDR.Item("Transaction_Number") & "/" & vDR.Item("Line_Number"))
              vAdjustmentCount = vAdjustmentCount + 1
              vAdjustmentTotal = vAdjustmentTotal + vDR.DoubleItem("Amount")
            End If
          Next vDR

          While vAdjustmentReferences.Count() > 0
            'Iterative loop to add totals on any Adjustments of Adjustments and add back in if they were in turn adjusted!
            For Each vDR In vDT.Rows
              If vDR.Item("Notes") = CStr(vAdjustmentReferences.Item(1)) Then
                vAdjustmentReferences.Add(vDR.Item("Batch_Number") & "/" & vDR.Item("Transaction_Number") & "/" & vDR.Item("Line_Number"))
                vAdjustmentCount = vAdjustmentCount + 1
                vAdjustmentTotal = vAdjustmentTotal + vDR.DoubleItem("Amount")
                'Override Declaration Number with that of Adjustment Transaction as it is the Declaration that
                'replaced the Original Declaration.
                vDeclarationNumber = IntegerValue(vDR.Item("Member_Number"))
              End If
            Next vDR
            vAdjustmentReferences.Remove((1))
          End While

          If vAdjustmentCount = 0 Or vAdjustmentTotal >= 0 Then
            'Either we have not previously adjusted this payment OR we have adjusted it but
            'balance of adjustments are positive so create a negative (reversal)
            With vDLU
              .InitForNew(vDeclarationNumber, (vRS.Fields(2).IntegerValue), pNewBatch, pNewTransaction, pNewline, vType, (vRS.Fields(3).DoubleValue * -1))
              .Save()
            End With
          End If
        End While
        vRS.CloseRecordSet()
      Next
    End Sub
    Public Sub InitForNew(ByRef pCdNumber As Integer, ByRef pContactNumber As Integer, ByRef pBatchNumber As Integer, ByRef pTransactionNumber As Integer, ByRef pLineNumber As Integer, ByVal pDeclarationOrCovenantNumber As String, ByRef pNetAmount As Double)
      Me.Init()

      Me.CdNumber = pCdNumber
      Me.ContactNumber = pContactNumber
      Me.BatchNumber = pBatchNumber
      Me.TransactionNumber = pTransactionNumber
      Me.LineNumber = pLineNumber
      Me.DeclarationOrCovenantNumber = pDeclarationOrCovenantNumber
      Me.NetAmount = pNetAmount
    End Sub

    Public Property BatchTransactionAnalysis As BatchTransactionAnalysis
      Get
        If mvBTA Is Nothing AndAlso Me.BatchNumber > 0 AndAlso Me.TransactionNumber > 0 AndAlso Me.LineNumber > 0 Then
          Me.BatchTransactionAnalysis = Me.GetRelatedInstance(Of BatchTransactionAnalysis)({ClassFieldItems.BatchNumber,
                                                                                    ClassFieldItems.TransactionNumber,
                                                                                    ClassFieldItems.LineNumber})
        End If
        Return mvBTA
      End Get
      Private Set(value As BatchTransactionAnalysis)
        mvBTA = value
      End Set
    End Property

    Private ReadOnly Property BatchTransaction As BatchTransaction
      Get
        Return If(Me.BatchTransactionAnalysis IsNot Nothing, Me.BatchTransactionAnalysis.BatchTransaction, Nothing)
      End Get
    End Property

    ''' <summary>
    ''' Returns all the Financial History Detail lines from the Batch Transaction Analysis that are for a Product flagged as eligible for Gift Aid
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property FinancialHistoryDetailLines As IList(Of FinancialHistoryDetail)
      Get
        Return Me.BatchTransactionAnalysis.GiftAidableDetailLines
      End Get
    End Property

    Public Overrides Sub Save(pAmendedBy As String, pAudit As Boolean, pJournalNumber As Integer)
      Save(pAmendedBy, pAudit, pJournalNumber, False)
    End Sub

    Public Overrides Sub Save(pAmendedBy As String, pAudit As Boolean, pJournalNumber As Integer, pForceAmendmentHistory As Boolean)
      If Me.BatchTransactionAnalysis IsNot Nothing Then
        If Me.BatchTransactionAnalysis.IsFinancialAdjustment Then
          'The claim amount of a reversed transaction is always the negative of the original transaction
          'If it's for a reversal of a reversal then the amount will be positive
          Me.NetAmount = -1 * Me.BatchTransactionAnalysis.Reversal.OriginalBatchTransactionAnalysis.GiftAidClaimedAmount
        Else
          Me.NetAmount = Me.FinancialHistoryDetailLines.ToList().Sum(Function(vFHDLine) vFHDLine.Amount)
        End If
      End If
      If Me.NetAmount = 0 Then 'zero-claim makes no sense
        If Me.Existing Then Me.Delete(pAmendedBy, True, pJournalNumber)
      Else
        MyBase.Save(pAmendedBy, pAudit, pJournalNumber, pForceAmendmentHistory)
      End If
    End Sub

#End Region

  End Class
End Namespace
